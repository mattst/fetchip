#!/bin/bash
##
##
## Description:      Script to retrieve an external IPv4 address from IP providing web sites.
## Requirements:     UNIX like OS / Bash / Requires either curl or wget to be installed.
## Usage:            getip [-m] [-f] [-c] [-v] -[h] [-t timeout_secs] [-s num_sources]
## Exit Status:      '0' on success, and non-zero on failure.
## Author:           Matthew Stanfield <jmstanfield@gmail.com>
## Version:          0.7
## Last Edited:      2012-07-23
## Homepage:         http://code.google.com/g/getip/
## License:          GNU General Public License v3 - http://www.gnu.org/copyleft/gpl.html
##
##
## The complete list of all utilities and Bash shell commands used by the getip script:
##
## awk, bc, curl, date, disown, echo, exit, getopts, grep, hash, kill, mktemp, printf, ps, 
## $RANDOM, rm, sed, sort, tr, uniq, unset, wc, wget. [wget or curl required, not both.]
##
## With the exception of wget and curl all of the above utilities and commands are either part of
## Bash, a POSIX required utility, or included in GNU coreutils, and they are expected to exist on
## all modern UNIX like operating systems. getip needs either wget or curl to be installed to
## facilitate the transfer of data from the source urls, (the script checks if wget and curl are
## installed or not and responds appropriately).
##
##
## getip is a script used to retrieve an external IPv4 address from behind a router using web
## sites which provide the IP address in plain text or HTML. Note: IPv4 only, not IPv6.
##
## getip echoes the IP address so that it is displayed in the shell or so that it can be stored in
## a variable if getip is called from within another script. As would be expected it's exit status
## is '0' on success, and '1' on failure (failure would usually mean that there is no web access).
## 
## Command line options (all optional):
##
## -m           MULTI; get the IP from multiple sources and check they are all the same (default).
## -f           FAST; get the IP from just one source in order to echo it more quickly than verify.
## -c           CHECK; display the IP address returned by all the sources.
## -s number    Set how many SOURCES to use for verification in verify mode. Range >=2 and <=5.
## -t seconds   Set the TIMEOUT for each source. Note: real numbers are permitted (e.g. '1.5').
## -v           VERBOSE; output information while the script is running.
## -h, --help   HELP; output program usage and help.
##
## The default mode is 'multi', so -m is only needed on the command line if the $operationMode
## variable has been altered by the user (only advanced users should even think of doing this).
##
## 
## Description of the 3 operation modes: MULTI, FAST, and CHECK.
##
## Note: In both multi and fast modes the $urlList array is randomized before use so that no one
## source is used more often than any other, the time taken to shuffle the array is negligible.
## In all modes if getip encounters a source which is unavailable, e.g. the web site is down, or
## the timeout is exceeded, it will immediately move on to the next source (there are over 50).
##
##
## MULTI (default mode)   - Command line switches: -m and/or -s number_of_sources
##                        - No switch necessary, MULTI mode is used be default.
##
## In multi mode getip will retrieve the IP address from more than one source and verify that all
## sources have supplied the same IP address. The variable $numIpToUseForMulti specifies how many
## sources to retrieve the IP address from before checking that they are all the same, the default
## value for $numIpToUseForMulti is 2, but it can be set on the command line with -s (>=2 <=5);
## however the default is considered to be sufficient due to the probability of 2 sources both 
## providing the same incorrect IP address being unlikely to occur. This is the default mode.
##
##
## FAST                   - Command line switch: -f
##
## In fast mode getip will retrieve the IP address from just one source with no verification. 
## The use of this mode instead of multi mode is almost always fine, and it is usually faster,
## although not always (for instance if the timeout is set larger than 1-2 seconds and a source
## happens to be chosen which is slow to respond). Using it can result in an incorrect IP address
## being supplied - although rare it can happen is certain circumstances, and did so a few times
## during approx. 250,000 tests over several weeks (by the same source which was subsequently
## removed). Sometimes sources stop providing IP addresses to 'visitors', either temporarily or
## permanently, but an example IP address might remain on the page, or an IP-like software version
## number might be present (embedded within the HTML) and which could be mistaken for a real IP.
## getip ignores any source which returns more than one IP-like number, but in the case of these
## 2 examples, a software version number (in the same form as an IP address), or an example IP
## address, could result in getip providing an incorrect IP address if one of these were to be
## the only IP-like number on the page. It would be a bad idea to use fast mode when calling getip
## from within other scripts or for any kind of important usage. It is suggested that it only be
## used when you already know what your IP address is and you're seeking confirmation, for
## instance if checking that you've sucessfully connected to or disconnected from a VPN.
## 
##
## CHECK                  - Command line switch: -c
##
## In check mode getip will display in the shell all the urls held in the $urlList array, the IP
## address which was retrieved from the source (or a message on failure), and the time taken to
## retrieve the IP address. In addition it displays some statistics at the end. It can be used
## by advanced users to check that all the sources are functioning correctly, or to check that a
## user addition to the urlList array works with the script. Non-expert users should download the
## latest version of the script instead of editing the $urlList array. Please contact the developer
## if the latest version of the script contains a source which returns an incorrect IP address.
##
##
## Description of the other command line options:
##
## MULTI, NUMBER OF SOURCES   - Command line switch: -s num_sources [Default 2, range: >=2 <=5.]
##
## Sets the number of sources to use in the multi operation mode. In the default multi mode, getip
## retrieves the IP address from more than one source (default 2) in order to be sure that the
## correct IP address has been retrieved. The allowed range is >=2 and <=5 (must be an integer)
## however the default of 2 is considered to be sufficient due to the probability of 2 sources both
## providing the same incorrect IP address being incredibly unlikely to occur.
##
##
## TIMEOUT, FOR EACH SOURCE   - Command line switch: -t seconds [Default dependant on mode,
##                                                               real numbers are permitted,
##                                                               range: >=0.2 <=30.]
##
## Default timeout for the multi operation mode:  1.25 seconds
## Default timeout for the fast operation mode:   1.00 seconds
## Default timeout for the check operation mode:  15.0 seconds
## [Advanced users can change the default timeout values in the script below.]
##
## Sets the timeout in seconds for each source, not an overall timeout for the script. When a source
## gives no response or is slow to respond, getip simply moves on to the next source in the $urlList
## array of sources. Each of the operation modes has its own default timeout (shown above), but
## -t seconds allows users to set their own value, real numbers are allowed e.g. '0.75', '1.5'.
## The allowed range is large, >=0.2 and <=30, as large variations in speed of web access and the
## user's physical location both mean a flexible timeout is sensible, however values less than 0.75
## or greater than 3 are not usually advisable in multi or fast mode - check mode is different, a 
## high timeout facilitates checking whether the sources are all functioning (at all) or not.
##
## There is no 'global' timeout feature for getip, however the timeout multiplied by the number of
## sources means there is a de facto 'global' timeout. Currently getip has 53 sources in the
## $urlList array so if the timeout were to be set to 1 second there would be an approximate 
## 'global' timeout of 53 seconds. In reality the chances of all sources failing is extraordinarily
## unlikely to occur unless there is no web access at all, in which case wget or curl would not be
## able to access the web and each source would fail rapidly, long before the timeout was reached,
## in a test with internet access turned off this took just under 1.2 seconds.
## 
##
## VERBOSE                - Command line switch: -v
##
## Turns verbose on - the script will output diagnostic information while it runs.
##
##
## HELP                   - Command line switch: -h or --help
##
## Outputs program usage and help, then exits.
##
##



##
## START OF SCRIPT.
##

# Set version number.
versionNum="0.7"

# Function which displays the script usage message / help.
Display_Usage_Message()
{
cat << EndOfDisplayUsageMessage
getip v. $versionNum - Get your IP address from behind a router.
Homepage: http://code.google.com/g/getip/
GNU General Public License v.3.

getip is a script used to retrieve an external IP address from behind a
router using web sites which provide the IP address in plain text or HTML.
Note: It retrieves IPv4 addresses only and not IPv6. When web sites which
provide IP addresses start to support IPv6, then IPv6 support will be added.

Usage:

getip [-m] [-f] [-c] [-v] [-h] [-t timeout_in_secs] [-s number_of_sources]

Command line options (all optional):

-m           Multi mode; get the IP from multiple sources and check they are
             all the same. In multi mode the default number of sources is 2.
             This is the default mode so using -m is optional.

-f           Fast mode; get the IP from just one source in order to echo it
             more quickly than in multi mode. Important: See 'notes' below.
             It is advisable that users only use fast mode to confirm their
             IP address when it is already known, for example if checking to
             see if connecting to a VPN has completed, in some circumstances
             an incorrect IP address can be returned in fast mode, there is
             more information about this in the 'notes' below, which should
             be read by users before they use it.

-c           Check mode; displays a table containing the url of each source,
             the IP address that each returned (or a failure message), the
             time taken to retrieve the IP address, and various statistics.

-s sources   Set the number of Sources to use for verification in multi mode.
             The valid range is >=2 and <=5. The default value is 2.
             The use of this switch automatically sets the mode to multi
             overriding all other mode settings including the use of -f or -c.

-t seconds   Set the Timeout for each source. This is not an overall timeout
             for the script. When a source gives no response or is slow to
             respond, getip moves on to the next source (there are over 50),
             and this is the timeout in seconds for each individual source.
             Note: Real numbers are permitted, e.g. 0.75, 1.5, .85, etc.
             The valid range is >=0.2 and <=30 (but these extremes are
             overkill, 0.2 being too low, and 30 being too high).
             The default timeout is dependant on mode:
             Multi mode: 1.25 secs, Fast mode: 1 sec, Check mode: 15 secs

-h           Help; display usage and help. Also: --help

-v           Verbose; display diagnostic information.

Notes:

The default is multi mode, so the -m switch is only needed on the command
line if the default operation mode has been changed in the script.

On rare occasions, when one of the web sources has changed, it is possible that
an incorrect IP address can be returned in fast mode. For example if that web
page no longer functions as a supplier of IP addresses but displays an example
IP address on the page. In over 250,000 tests over several weeks, this
happened twice, both by the same web site which was then removed as a source.
Subsequently another site stopped working and it had a software version
number, in the same form as an IP address, embedded in the page's HTML, this
was returned as the IP address. This site was also removed as a source, but
over time, these type of occurrences are inevitable. Fast mode in not perfectly
reliable, it should only be used to output in the shell for visual confirmation
of your IP address when you have some idea of what it should be. Fast mode
should not be used when calling getip from within another script.

It is suggested that users stick to multi mode as the chances of 2 (the
default number of sources to check) or more of the sources both no longer
functioning properly and both providing the same incorrect IP address is very
small. Multi mode is usually very fast, returning a verified IP address within
a few seconds (with the default number of sources and timeout), often faster.

Users should check from time to time to see if a newer version of the script
has been released. By using the newest version of getip, users can ensure
that the web sources list remains up to date. Users can check if the current
list of sources are all functioning by using the -c (check) switch. 

Get the latest version of getip here: http://code.google.com/g/getip/
EndOfDisplayUsageMessage
}


# Function which sends the various error messages to STDERR.
Output_Error_Message()
{
    # Assign $errToDisplay the value of the 1st function arg (NOT script arg).
    local errToDisplay=$1

    # Assign $additionalInfo the value of the 2nd function arg (NOT script arg).
    # Some errors will need some extra information to be displayed.
    local additionalInfo=$2

    # The standard error message for all errors.

    echo "getip v. $versionNum - Get your IP address from the web." >&2
    echo "" >&2
    echo "GNU General Public License v.3" >&2
    echo "http://code.google.com/g/getip/" >&2
    echo "" >&2
    echo "An error has occurred, use \"getip -h\" for usage and help." >&2
    echo "" >&2

    # The error messages:

    # The arg given to the -s switch is invalid.
    if [ "$errToDisplay" = "NumSourcesArgInvalid" ]; then 
        echo "The argument given to the -s switch is invalid: $additionalInfo" >&2
        echo "" >&2
        echo "The -s switch sets the number of sources to use for verification in" >&2
        echo "multi mode and it requires a positive number in the range >= 2 and <= 5." >&2
        echo "The default number of sources to use for verification is 2." >&2
        echo "" >&2
        echo "e.g. \"getip -s 2\", \"getip -s 3\", etc." >&2
    fi

    # The arg given to the -t switch is invalid.
    if [ "$errToDisplay" = "TimeoutArgInvalid" ]; then 
        echo "The argument given to the -t switch is invalid: $additionalInfo" >&2
        echo "" >&2
        echo "The -t switch sets the timeout value in seconds for each source." >&2
        echo "It requires the number of seconds (real numbers are permitted)." >&2
        echo "The valid range is between >=0.2 and <=30 although for multi and" >&2
        echo "fast modes a value between >=0.75 and <=3 is suggested." >&2
        echo "See help for the default timeout values of the various modes." >&2
        echo "" >&2
        echo "e.g. \"getip -t 1\", \"getip -t 0.75\", \"getip -t 2.5\", etc." >&2
    fi

    # The switch entered is invalid.
    if [ "$errToDisplay" = "OptionInvalid" ]; then 
        echo "An invalid option has been entered: -$additionalInfo" >&2
        echo "" >&2
        echo "Usage: getip [-m] [-f] [-c] [-h] [-t timeout_secs] [-s num_sources]" >&2
        echo "" >&2
        echo "See usage and help." >&2
    fi

    # The arg is missing for a switch that requires an arg.
    if [ "$errToDisplay" = "ArgMissing" ]; then 
        echo "The argument is missing for the option: -$additionalInfo" >&2
        echo "" >&2
        echo "Usage: getip [-m] [-f] [-c] [-v] [-h] [-t timeout_secs] [-s sources_num]" >&2
        echo "" >&2
        echo "See usage and help." >&2
    fi

    # Somehow (user editing) an invalid operation mode has been set.
    if [ "$errToDisplay" = "InvalidOperationMode" ]; then 
        echo "Invalid operation mode: $additionalInfo" >&2
        echo "" >&2
        echo "Someone has edited the getip script and made an error when setting the" >&2
        echo "operation mode variable, it is not set to a valid operation mode." >&2
    fi

    # Neither wget nor curl are installed on the OS.
    if [ "$errToDisplay" = "WgetAndCurlNotInstalled" ]; then 
        echo "The getip script requires either 'wget' or 'curl' to access the web, please" >&2
        echo "install one of them in order to use this script. Both wget and curl are" >&2
        echo "programs that can retrieve web pages, and they are widely available for all" >&2
        echo "UNIX/Linux based systems. The getip script works equally well with either." >&2
    fi

    # Creating the temp file failed.
    if [ "$errToDisplay" = "TempFileCreationFailed" ]; then 
        echo "The getip script failed to create a required temporary file." >&2
        echo "" >&2
        echo "The script uses 'mktemp' to create temporary files. It is possible that mktemp" >&2
        echo "is not on your system although it is a standard component of UNIX/Linux based" >&2
        echo "systems. There may be a problem with the environment variable \$TMPDIR being" >&2
        echo "incorrectly set, or with creating files in the standard '/tmp/' directory," >&2
        echo "it is also possible that there is a significant problem with your file system." >&2
    fi

    # In check mode all the urls failed.
    if [ "$errToDisplay" = "CheckModeAllUrlsFailed" ]; then 
        echo "In check mode - the getip script has failed to get an IP address from every" >&2
        echo "single one of the web sources (there are over 50)." >&2
        echo "" >&2
        echo "The most likely reasons for this failure are that there is currently no web" >&2
        echo "access available to the computer, some part of the security system is denying" >&2
        echo "getip a web connection, or possibly the timeout value has been set very low." >&2
        echo "Diagnosing the problem further than that is beyond the scope of this error" >&2
        echo "message, in short: you're on your own." >&2
        echo "" >&2
        echo "P.S. If you have web access and this script is very old, you could download" >&2
        echo "the latest version of the script from the url above, otherwise YAOYO." >&2
    fi
}

# Test error messages:
#Output_Error_Message "NumSourcesArgInvalid" "8"
#Output_Error_Message "TimeoutArgInvalid" "60"
#Output_Error_Message "OptionInvalid" "z"
#Output_Error_Message "ArgMissing" "t"
#Output_Error_Message "InvalidOperationMode" "NONE"
#Output_Error_Message "WgetAndCurlNotInstalled"
#Output_Error_Message "TempFileCreationFailed"
#Output_Error_Message "CheckModeAllUrlsFailed"
#exit 0


# The following array of source urls all provide the IP address of the connecting machine. They
# each return an IP address either on its own or within some plain text or HTML. Some 'show your
# IP address' web pages have an example IP address on the page - such web pages have not been added
# to the array. Note that pages which contain more than 1 unique IP address would be ignored by
# getip, they would not cause the script to supply the wrong IP address.

# IMPORTANT: The $urlList array MUST BE INDEXED IN NUMERICAL SEQUENCE FROM 0 or the function
# Randomize_Url_List() will not randomize the array correctly, this is very important!!

# Note: Be careful when editing of trailing '/'s at the end of urls. Sometimes it is essential 
# that they are there, sometimes it is essential that they are not there, so paste accurately.

urlList[0]="http://tnx.nl/ip"
urlList[1]="http://checkip.dyndns.org"
urlList[2]="http://www.sputnick-area.net/ip"
urlList[3]="http://icanhazip.com"
urlList[4]="http://api.externalip.net/ip/"
urlList[5]="http://myip.dnsomatic.com"
urlList[6]="http://ifconfig.me/ip"
urlList[7]="http://ip.appspot.com"
urlList[8]="http://ipcheckit.com"
urlList[9]="http://automation.whatismyip.com/n09230945.asp"
urlList[10]="http://iplookup.flashfxp.com"
urlList[11]="http://ip-check.info/?lang=en"
urlList[12]="http://www.123myip.co.uk"
urlList[13]="http://my-ip-address.com"
urlList[14]="http://ipchicken.com"
urlList[15]="http://www.lawrencegoetz.com/programs/ipinfo/"
urlList[16]="http://phpweby.com/services/iplocation"
urlList[17]="http://www.dnsstuff.com/"
urlList[18]="http://www.dslreports.com/whois"
urlList[19]="http://www.whatsmyip.us"
urlList[20]="http://ip-lookup.net/"
urlList[21]="http://www.infosniper.net/"
urlList[22]="http://www.ip-address.org/lookup/ip-locator.php"
urlList[23]="http://ip-address-lookup-v4.com/email-trace.php"
urlList[24]="http://geomaplookup.net/"
urlList[25]="http://www.ipaddresslocation.org/ipaddress.shtml"
urlList[26]="http://www.geobytes.com/IpLocator.htm?GetLocation"
urlList[27]="http://www.webyield.net/cgi-bin/ip.cgi"
urlList[28]="http://whatismyipaddress.com/ip-lookup"
urlList[29]="http://www.ipchecking.com"
urlList[30]="http://network-tools.com"
urlList[31]="http://submit.apnic.net/templates/yourip.html"
urlList[32]="http://www.ipligence.com/geolocation"
urlList[33]="http://www.easywhois.com/index.php?mode=myip"
urlList[34]="http://www.ipgoat.com"
urlList[35]="http://www.dnswatch.info/what's-my-ip"
urlList[36]="http://www.clientip.net"
urlList[37]="http://speedchecker.org/?page=connection_details"
urlList[38]="http://www.iplocation.net"
urlList[39]="http://en.utrace.de"
urlList[40]="http://remote.12dt.com"
urlList[41]="http://www.iptools.com"
urlList[42]="http://www.geoiptool.com"
urlList[43]="http://www.ip.cc/index.php"
urlList[44]="http://www.ipnumber.eu/ip/"
urlList[45]="http://www.formyip.com/ipcountry.php"
urlList[46]="http://www.urgentclick.com/whats-my-ip-address.php"
urlList[47]="http://www.who.is"
urlList[48]="http://www.geoip.co.uk/"
urlList[49]="http://www.showmyip.com"
urlList[50]="http://networktools.nl"
urlList[51]="http://www.spyber.com/ip-lookup.php"
urlList[52]="http://www.ip-lookup.com"
urlList[53]="http://www.ipfetch.net"

# $urlListLength holds the number of urls in $urlList (0 indexed, so final element is len-1).
urlListLength=${#urlList[*]}

# $operationMode holds the operation mode, default 'MULTI'. Possible values: 'MULTI', 'FAST',
# or 'CHECK' - but should be left as 'MULTI' in the line below.
operationMode="MULTI"

# Sets the default number of sources to use in multi mode. Recommended: 2 (Not: < 2 or > 5).
numIpToUseForMulti="2"

# Set the default timeout in seconds for the retrieval of each source. A different default timeout
# can be set for each mode. Timeouts may be fractions of a second, Eg. 1.5, 0.75.

# In fast mode keep the timeout low, so that if a source is offline or slow to respond, the script
# will move on to the next source. Recommended: 0.75 to 1.5.
timeoutFastMode="1"

# Same applies as fast mode, unless setting $numIpToUseForMulti above the recommended level, of
# 2, in which case increase this timeout a little. Recommended: 1 to 3.0.
timeoutMultiMode="1.25"

# In check mode set the timeout much higher to give every source a good chance to succeed and to
# see how long each of the sources take. Recommended: 15.
timeoutCheckMode="15"

# Flag variable to hold if the user has set the num source IPs to use for multi (the -s switch).
userSetNumIpToUseForMulti="FALSE"

# Flag variable to hold if the user has set a timeout (the -t switch).
userSetTimeout="FALSE"

# Flag variable to hold if the user has turned on verbose reporting (the -v switch).
verbose="FALSE"

# Constants to hold the various exit statuses.
ExitStatusSuccess="0"
ExitStatusErrorNumSourcesArgInvalid="1"
ExitStatusErrorTimeoutArgInvalid="2"
ExitStatusErrorSwitchInvalid="3"
ExitStatusErrorArgMissing="4"
ExitStatusErrorOperationModeInvalid="5"
ExitStatusErrorWgetAndCurlNotInstalled="6"
ExitStatusErrorTempFileCreationFailed="7"
ExitStatusErrorMultiOrFastModeGettingIpFailed="8"
ExitStatusErrorCheckModeAllUrlsFailed="9"

# Before handling the arguments, check if the first arg is "--help", if so display help and exit.
# This is currently the only long option supported. 
if [ "$1" = "--help" ]; then
    Display_Usage_Message
    exit "$ExitStatusSuccess"
fi

# Use getopts to handle the command line arguments. ToDo: Add long option support.
while getopts ":cfmvhs:t:" option; do

    case $option in

        c)
            # -c has been used, set operation mode to check.
            operationMode="CHECK"
            ;;

        f)
            # -f has been used, set operation mode to fast.
            operationMode="FAST"
            ;;

        m)
            # -m has been used, set operation mode to multi.
            operationMode="MULTI"
            ;;

        v)
            # -v has been used, turn on verbose mode.
            verbose="TRUE"
            ;;

        h)
            # -h has been used, display help and then exit.
            Display_Usage_Message
            exit "$ExitStatusSuccess"
            ;;

        s)
            # -s num has been used, set the num source IPs to use and flag variable.
            numIpToUseForMulti=$OPTARG
            userSetNumIpToUseForMulti="TRUE"

            # Use sed to check that $numIpToUseForMulti is a single digit >=2 and <=5.
            numMultiMin="2"
            numMultiMax="5"

            sedExpIsNumInRange="s/^[$numMultiMin-$numMultiMax]\{1\}$/SINGLE_DIGIT_IN_RANGE/g"

            isNumInRange=$(echo "$numIpToUseForMulti" | sed "$sedExpIsNumInRange")

            # A single digit in range has not been entered.
            if [ "$isNumInRange" != "SINGLE_DIGIT_IN_RANGE" ]; then
                Output_Error_Message "NumSourcesArgInvalid" "$numIpToUseForMulti"
                exit "$ExitStatusErrorNumSourcesArgInvalid"
            fi
            ;;

        t)
            # -t seconds has been used, set the timeout flag and arg variables.
            timeoutSecondsArg=$OPTARG
            userSetTimeout="TRUE"

            # Check that $timeoutSecondsArg is a number, int or real. This is a Bash hack to use
            # awk to check whether a variable is any kind of number (int or real).
            awkIsNum='END { if ($1 + 0 == $1) print "Num"; else print "NotNum" }'
            awkIsNumRetVal=$(echo "$timeoutSecondsArg" | awk "$awkIsNum")
            
            if [ "$awkIsNumRetVal" = "NotNum" ]; then
                Output_Error_Message "TimeoutArgInvalid" "$timeoutSecondsArg"
                exit "$ExitStatusErrorTimeoutArgInvalid"
            fi

            # Check that $timeoutSecondsArg is a positive number in range, >=0.2 and <=30.
            timeoutRangeMin="0.2"
            timeoutRangeMax="30"

            bcExpCheckPositive="if ($timeoutSecondsArg < $timeoutRangeMin || \
                                    $timeoutSecondsArg > $timeoutRangeMax) 1 else 0"

            bcExpCheckPositiveRetVal=$(echo "$bcExpCheckPositive" | bc -l)

            # A positive number in range has not been entered.
            if [ "$bcExpCheckPositiveRetVal" -eq "1" ]; then
                Output_Error_Message "TimeoutArgInvalid" "$timeoutSecondsArg"
                exit "$ExitStatusErrorTimeoutArgInvalid"
            fi
            ;;
            
        \?)
            # User entered an invalid option, this won't spot an arg with no '-' prefix,
            # args with no '-' prefix will be ignored: e.g. 'getip f' (the 'f' is ignored).
            Output_Error_Message "OptionInvalid" "$OPTARG"
            exit "$ExitStatusErrorSwitchInvalid"
            ;;

        :)
            # User omitted the required arg of a switch (i.e. -s or -t).
            Output_Error_Message "ArgMissing" "$OPTARG"
            exit "$ExitStatusErrorArgMissing"
            ;;
    esac
done

# The use of the -s switch to set the number of source IPs to use for multi mode, both implies
# and forces the use of the multi operation mode, make sure that it is set.
if [ "$userSetNumIpToUseForMulti" = "TRUE" ]; then 
    operationMode="MULTI"
fi

# Set the appropriate $timeout and check that the operation mode is valid.

if [ "$operationMode" = "FAST" ]; then 
    timeout=$timeoutFastMode

elif [ "$operationMode" = "MULTI" ]; then 
    timeout=$timeoutMultiMode

elif [ "$operationMode" = "CHECK" ]; then 
    timeout=$timeoutCheckMode

else
    Output_Error_Message "InvalidOperationMode" "$operationMode"
    exit "$ExitStatusErrorOperationModeInvalid"
fi

# The user set the timeout on the command line, this overrides the default timeout.
if [ "$userSetTimeout" = "TRUE" ]; then 
    timeout=$timeoutSecondsArg
fi

# Either wget or curl can be used to download the source urls.
# $urlDownloadProgram will hold which to use, either: 'WGET' or 'CURL'.

# Set the default download program (which to use if both are installed).
urlDefaultDownloadProgram="WGET"

# Check whether wget and curl are installed, at least one is required.
hash wget 1>&2 2>/dev/null
isWgetInstalled=$?
hash curl 1>&2 2>/dev/null
isCurlInstalled=$?

# Decide which of wget or curl to use for downloading.

# If both wget and curl are installed, use the default.
if [ "$isWgetInstalled" -eq "0" -a "$isCurlInstalled" -eq "0" ]; then 
    urlDownloadProgram="$urlDefaultDownloadProgram"

# If only wget is installed, use that.
elif [ "$isWgetInstalled" -eq "0" -a "$isCurlInstalled" -ne "0" ]; then 
    urlDownloadProgram="WGET"

# If only curl is installed, use that.
elif [ "$isCurlInstalled" -eq "0" -a "$isWgetInstalled" -ne "0" ]; then 
    urlDownloadProgram="CURL"

# If neither wget nor curl are installed, display error and exit.
else
    Output_Error_Message "WgetAndCurlNotInstalled"
    exit "$ExitStatusErrorWgetAndCurlNotInstalled"
fi


# Function that randomizes the $urlList array. Since this script is being publicly released it is
# sensible to randomize the sources so as not to place undue pressure on any one server. This is
# an implementation of the Knuth shuffle (aka Fisher-Yates) algorithm, which is a very efficient
# randomizer, needing just one pass through an array. http://en.wikipedia.org/wiki/Knuth_shuffle
# IMPORTANT: THE $urlList ARRAY MUST BE INDEXED IN NUMERICAL SEQUENCE FROM 0 FOR THIS FUNCTION.
Randomize_Url_List()
{
    # Bash $RANDOM provides a random number in the range 0..32767 so 32768 possible values.
    local randMax="32768"

    # Start at the length of the array.
    local index=$urlListLength

    # The use of > 1 (rather than the more usual > 0) needs a moment to understand - if instead
    # it was > 0 then the final iteration, at 1, would always swap index 0 with itself.
    while [ "$index" -gt "1" ]; do
    
        # Modulo bias avoidance as per Knuth shuffle algorithm description. Use bc to calculate the
        # highest usable random number so that the modulo by index calculation will not result in
        # any modulo bias. [scale=0 means integer arithmetic, division will be rounded down.]
        
        local bcExpHighestAcceptableRandNum="scale=0; (($randMax / $index) * $index) - 1"
        local highestAcceptableRandNum=$(echo "$bcExpHighestAcceptableRandNum" | bc)

        # Get a random number in the range 0..index-1, THEN decrement $index, so that the current
        # index will be randomly swapped with any <= index.

        local randNum=$RANDOM

        # Make sure that $randNum is within the modulo bias avoidance range.
        while [ "$randNum" -gt "$highestAcceptableRandNum" ]; do 
            randNum=$RANDOM
        done

        let "randNum = randNum % index"
        let "index = index - 1"
        
        # Swap the $index url with the $randNum url.
        local tempUrl=${urlList[$index]}
        urlList[$index]=${urlList[$randNum]}
        urlList[$randNum]=$tempUrl

    done
}


# Function that retrieves the source's content and returns all unique IP addresses in it. The
# bulk of the function handles a timeout facility; neither curl nor wget accurately honour any
# timeout value which has been set nor do they allow timeouts in fractions of a second. Since
# getip uses many different sources a low timeout is used, if one source fails to return very
# quickly then the next source is tried. With this methodology a reliable and accurate low
# timeout is required, this function provides it.
Get_Ip_From_Url()
{
    # Assign $urlToDownload the value of the 1st function arg (NOT script arg).
    local urlToDownload=$1
    
    # Assign $tempFileName the value of the 2nd function arg (NOT script arg). This will be used
    # to store the contents of the url.
    local tempFileName=$2

    # Store the start time to be used for the timeout.
    local timeoutStart=$(date +%s.%N)

    # Download the url and store its contents in the temp file. The process is forked to facilitate
    # the timeout procedure. The use of disown, which removes a job from the shell's active jobs
    # table, is so that if the process is later killed (which it will be if it timed out) then
    # no shell message is displayed.

    # Some sources (very few) won't work without the user agent header being sent.
    # We are not trying to hide that this is a script, use a user agent header like googlebot's:
    # Googlebot 2.1: "Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)"
    userAgent="Mozilla/5.0 (compatible; getipscript/$versionNum; +http://code.google.com/g/getip/)"

    # Test only: My Firefox user agent:
    # userAgent="Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:13.0) Gecko/20100101 Firefox/13.0.1"

    # Use wget to download the url.
    if [ "$urlDownloadProgram" = "WGET" ]; then

        wget --quiet --tries=1 --user-agent="$userAgent" --output-document=- \
             "$urlToDownload" > "$tempFileName" &

        urlDownloadProcessId=$!
    fi

    # Use curl to download the url.
    if [ "$urlDownloadProgram" = "CURL" ]; then

        curl --silent --user-agent "$userAgent" "$urlToDownload" > "$tempFileName" &

        urlDownloadProcessId=$!
    fi

    # For some reason even if kill has both stdout and stderr redirected to /dev/null the death of
    # the process is still output, using disown to remove the job from the shell's active jobs
    # table stops this from happening so there are no unsightly terminal messages.
    disown "$urlDownloadProcessId"
    
    # The following loop handles the timeout procedure for the url download process. ps is used to
    # see if the download process is still alive. The loop will finish when the process is done or
    # when the timeout is exceeded.
  
    local isUrlDownloadDone="FALSE"
    local isUrlDownloadTimedOut="FALSE"

    while [ "$isUrlDownloadDone" = "FALSE" -a $isUrlDownloadTimedOut = "FALSE" ]; do

        # Store whether the url download process is still listed by ps.
        ps -e | grep --quiet "$urlDownloadProcessId"
        local processGrepRetVal=$?

        # If the url download process has finished.
        if [ "$processGrepRetVal" -ne "0" ]; then
            isUrlDownloadDone="TRUE"

        # If the url download process has not finished.
        else
            # Store the current time to be used for the timeout.
            local timeoutNow=$(date +%s.%N)

            # Use bc to check if the timeout has been exceeded.
            local bcExpTimeout="if ($timeoutNow - $timeoutStart > $timeout) 1 else 0"
            local bcExpTimeoutRetVal=$(echo "$bcExpTimeout" | bc -l)

            # The timeout has been exceeded.
            if [ "$bcExpTimeoutRetVal" -eq "1" ]; then
                isUrlDownloadTimedOut="TRUE"
            fi
        fi
    done

    # This grep expression is a basic match for an IP address. Not using quantifiers, i.e. {1,3}, in
    # the first and last sections of this expression, is deliberate and done so that grep does not
    # examine something like '1111.222.222.1111' and match just the '111.222.222.111' part of it,
    # ignoring the first and last char, and in so doing cause something that is definitely not
    # an IP address to get mistaken for something that might be. The function Is_Ip_Address() will
    # later determine whether a completely valid IP address has been retrieved or not.
    local grepIpExpr="[0-9]+\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]+"
    
    # The url download process completed. Extract IP-like sequences from the temp file and remove
    # any duplicates, then echo the IP address(es) so they can be placed in a variable at the point
    # of function invocation.

    if [ "$isUrlDownloadDone" = "TRUE" ]; then

        # Use --only-matching to retrieve only the text that matches exactly.
        local ipAddressMatch=$(grep --only-matching --extended-regexp \
                               "$grepIpExpr" < "$tempFileName" | sort -n | uniq)

        echo "$ipAddressMatch"
    fi

    # The url download process timed out, kill the process (and make doubly sure).

    # Since the program being killed has been disowned (removed from the shell's active jobs
    # table) I do not think the redirect of stdout and stderr to /dev/null is necessary to hide
    # the kill messages, it is not necessary on the 2 Linux systems used to test the script
    # (Ubuntu and Debian), but other systems may vary, so I'm leaving them in because they won't
    # do any harm and may prevent messages that are not wanted on some other UNIX/Linux OSes.

    if [ "$isUrlDownloadTimedOut" = "TRUE" ]; then
        kill -INT "$urlDownloadProcessId" > /dev/null 2>&1
        local killRetVal=$?
        if [ "$killRetVal" -ne "0" ]; then
            kill -KILL "$urlDownloadProcessId" > /dev/null 2>&1
        fi
    fi

    # If the download process completed return 0, if it timed out return 1.
    if [ "$isUrlDownloadDone" = "TRUE" ]; then
        return 0
    else
        return 1
    fi
}


# Function that tests if its input is a properly formed IP address, if so return 0, else return 1.
Is_Ip_Address()
{
    # Assign $ip the value of the 1st function arg (NOT script arg).
    local ip=$1
    
    # Get the string length of $ip.
    local ipLength=${#ip}

    # IP length: min "n.n.n.n" (7 chars), max "nnn.nnn.nnn.nnn" (15 chars).
    local ipLenMin="7"
    local ipLenMax="15"

    # If $ip is too short or too long to be an IP address, return immediately.
    # Also makes sure that any url which returned more than 1 unique IP is ignored.

    if [ "$ipLength" -lt "$ipLenMin" ]; then 
        return 1
    elif [ "$ipLength" -gt "$ipLenMax" ]; then 
        return 2
    fi

    # Perform a sed operation on $ip which replaces an exact string match of 4 1-3 digit numbers
    # delimited by 3 '.'s with "ALL_OK" in order to determine whether $ip is in the correct form.

    # BRE (Basic Regular Expression) version for sed:
    local sedExpIpCheck="s/^[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}$/ALL_OK/g"

    # Extended Regular Expression version for sed, in case it's ever needed.
    # local sedExpIpCheck="s/^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$/ALL_OK/g"

    local isIpCorrectlyFormed=$(echo "$ip" | sed "$sedExpIpCheck")

    # The IP address is not correctly formed.
    if [ "$isIpCorrectlyFormed" != "ALL_OK" ]; then
        return 3;
    fi

    # The IP address is correctly formed, check that its numbers are in the range >= 0 and <= 255.

    local ipNumMin="0"
    local ipNumMax="255"

    # Split $ip at the dots and iterate through the 4 numbers.
    for ipNum in $(echo "$ip" | tr "." " "); do
        if [ "$ipNum" -lt "$ipNumMin" -o "$ipNum" -gt "$ipNumMax" ]; then 
            return 4
        fi
    done

    # If the function has not already returned then $ip must contain a properly formed IP address.
    return 0
}


# Function that checks that all the IP addresses passed to it in an array are exactly the same.
# It is used to check that all the IP addresses retrieved in multi mode are identical.
Multi_Ip_Check()
{
    # Assign the array of IP addresses that's been passed to this function to $ipList.
    local ipList=("$@")

    # Iterate through the array checking that all the IP addresses are the same.
    for ipToCheck in "${ipList[@]}"; do

        # If $ipToCheck is not the same as the first IP address in the array, return 1.
        if [ "$ipToCheck" != "${ipList[0]}" ]; then
            return 1
        fi
    
    done

    # All the IP addresses in the array are the same, return 0.
    return 0
}


# Initiate the various variables used for stats in the check operation mode.
statsValidIpAddressList=""
statsTotalValidIp="0"
statsTotalInValidIp="0"
statsTimeTotal="0"
statsTimeFastest="0"
statsTimeSlowest="0"

# Add IP's address, validity, and retrieval time to the statistics variables (used in check mode).
Add_To_Stats()
{
    # Assign the IP address, its validity, and retrieval time to local variables.
    local ipAddressForStats=$1
    local ipValidForStats=$2
    local timeTakenForStats=$3

    # If the IP address is a valid one.
    if [ "$ipValidForStats" = "VALID_IP" ]; then

        # Add the IP address to the list of valid IP addresses. [The trailing space is essential.]
        statsValidIpAddressList+="$ipAddressForStats "
        
        # Add one to the counter of valid IP addresses.
        let "statsTotalValidIp = statsTotalValidIp + 1"

        # Add the time taken to the overall time taken counter.
        local bcExpTotalTime="$statsTimeTotal + $timeTakenForStats"
        statsTimeTotal=$(echo "$bcExpTotalTime" | bc -l)

        # The first time this function is called, set the time fastest and slowest variables.
        if [ "$statsTimeFastest" = "0" ]; then statsTimeFastest="$timeTakenForStats"; fi
        if [ "$statsTimeSlowest" = "0" ]; then statsTimeSlowest="$timeTakenForStats"; fi

        # Check if $timeTakenForStats is the new fastest or slowest time.
        local bcExpTimeFastest="if ($timeTakenForStats < $statsTimeFastest) 1 else 0"
        local bcExpTimeSlowest="if ($timeTakenForStats > $statsTimeSlowest) 1 else 0"
        local bcRetValTimeFastest=$(echo "$bcExpTimeFastest" | bc -l)
        local bcRetValTimeSlowest=$(echo "$bcExpTimeSlowest" | bc -l)
        if [ "$bcRetValTimeFastest" = "1" ]; then statsTimeFastest="$timeTakenForStats"; fi
        if [ "$bcRetValTimeSlowest" = "1" ]; then statsTimeSlowest="$timeTakenForStats"; fi
    fi

    # If the IP address is not valid.
    if [ "$ipValidForStats" != "VALID_IP" ]; then

        # Add one to the counter of invalid IP addresses.
        let "statsTotalInValidIp = statsTotalInValidIp + 1"
    fi
}


# Display the statistics variables (used in check mode).
Display_Stats()
{
    echo "-----------------------------------------------------------------------------"

    # Test purposes only:
    # statsValidIpAddressList+="123.123.123.123 255.255.255.255 192.168.1.1 123.123.123.123 192.168.1.1 "

    # Calculate the mean average of the successful retrieval times, reduce to 3 decimal places.
    local bcExpMean="$statsTimeTotal / $statsTotalValidIp"
    local timeMean=$(printf "%.3F" $(echo "$bcExpMean" | bc -l))

    # Echo the statistics.

    local msg=""

    msg='{ printf "%-61s %s\n", "Total Number Sites Checked", $1}'
    echo "$urlListLength" | awk "$msg"

    msg='{ printf "%-61s %s\n", "IP Addresses - Successfully Retrieved", $1}'
    echo "$statsTotalValidIp" | awk "$msg"

    msg='{ printf "%-61s %s\n", "IP Addresses - Failed (Timed Out / Invalid IP)", $1}'
    echo "$statsTotalInValidIp" | awk "$msg"

    msg='{ printf "%-61s %s\n", "Fastest IP Successful Retrieval (sec)", $1}'
    echo "$statsTimeFastest" | awk "$msg"

    msg='{ printf "%-61s %s\n", "Slowest IP Successful Retrieval (sec)", $1}'
    echo "$statsTimeSlowest" | awk "$msg"

    msg='{ printf "%-61s %s\n", "Mean Average IP Successful Retrieval (sec)", $1}'
    echo "$timeMean" | awk "$msg"

    # Trim leading and trailing whitespace from $statsValidIpAddressList using sed.
    sedExpTrim='s/^[ \t]*//g;s/[ \t]*$//g'
    statsValidIpAddressListTrim=$(echo "$statsValidIpAddressList" | sed "$sedExpTrim")

    # Calculate the number of unique IP addresses held in $statsValidIpAddressList.
    numUniqueIp=$(echo "$statsValidIpAddressListTrim" | tr " " "\n" | sort -n | uniq | wc -l)

    msg='{ printf "%-61s %s\n", "Unique IP Addresses Retrieved (Should Be 1)", $1}'
    echo "$numUniqueIp" | awk "$msg"

    # Echo a warning if the number of unique IP addresses is > 1, and list them.
    if [ "$numUniqueIp" -gt "1" ]; then
        echo ""
        echo "WARNING: The number of unique IP addresses retrieved exceeds one. It should be"
        echo "exactly one - your IP address - returned by all the sources used for IP address"
        echo "retrieval. One or more of the sources is no longer returning IP addresses"
        echo "correctly. You should download the most recent version of the getip script."
        echo "Advanced users can edit the sources in the script's urlList array to remove any"
        echo "sources which are no longer functioning. If the latest version of the script"
        echo "has a non-functioning source in it, please contact the developer."
        echo ""

        # Echo each unique IP address and its number of occurrences.
        statsValidIpAddressListSplit=$(echo "$statsValidIpAddressListTrim" | tr " " "\n")
        echo "Unique IP Addresses Retrieved List (IP Address - Num. Occurrences):"
        awkExpIpCount='{ count[$1]++ } END { for (j in count) printf "%-18s-   %d\n", j, count[j]}'
        echo "$statsValidIpAddressListSplit" | awk "$awkExpIpCount" | sort -nr
    fi

    echo "-----------------------------------------------------------------------------"
}


# Flag variable to hold whether in multi or fast mode, some things are only done in these modes.
if [ "$operationMode" = "MULTI" -o "$operationMode" = "FAST" ]; then
    operationModeIsMultiOrFast="TRUE"
else
    operationModeIsMultiOrFast="FALSE"
fi

# Flag variable to hold whether to calculate the time taken to get the IP address,
# this will only be done in either check mode or if verbose is set.
if [ "$operationMode" = "CHECK" -o "$verbose" = "TRUE" ]; then
    timeIpRetrieval="TRUE"
else
    timeIpRetrieval="FALSE"
fi

# If verbose is set, echo various diagnostic information.
if [ "$verbose" = "TRUE" ]; then
    echo "Script: getip v. $versionNum"
    echo "Number of source urls: $urlListLength"
    echo "Operation mode: $operationMode"
    if [ "$operationMode" = "MULTI" ]; then
        echo "Number of sources to use in multi mode: $numIpToUseForMulti"
    fi
    echo "Timeout for each source (seconds): $timeout"
    echo "Web access utility: $urlDownloadProgram"
fi

# Call the function which randomizes the $urlList array, multi or fast mode only.
if [ "$operationModeIsMultiOrFast" = "TRUE" ]; then

    if [ "$verbose" = "TRUE" ]; then
        echo ""
        echo "Randomizing the url list array (the sources list)"
    fi

    Randomize_Url_List
fi

# Array to hold the IP addresses retrieved in multi mode.
multiIpList=""

# Counter to hold how many IP addresses have so far been retrieved in multi mode.
multiIpCounter="0"

# For testing.
#multiIpList[0]="192.111.111.111"
#let "multiIpCounter = multiIpCounter + 1"

# For testing.
#urlList[0]="http://www.i-dig.info/ipfake.txt"
#urlList[1]="http://www.i-dig.info/ipnone.txt"
#urlList[0]="http://whatismyipaddress.com/ip-lookup"
#urlList[0]="http://whatismyipaddress.com/ip-lookup"
#urlList[1]="http://ip-address-lookup-v4.com/email-trace.php"
#urlList[2]="http://www.showmyip.com"

# For testing.
#numIpToUseForMulti=10

# The script's main loop, iterate through the urls in the $urlList array. If in multi or fast mode
# the script will exit from within this loop if the IP address is successfully retrieved (and, if
# in multi mode, then verified). If in check mode the loop will iterate through to completion.
for url in "${urlList[@]}"; do

    # The function Get_Ip_From_Url() uses a temp file in which to store the contents of $url.
    # Since you can't exit the script from within a function (exit just exits the function), the
    # temp file is created below and its path passed to the function, that way if mktemp fails
    # the script can then exit with an error message when the exit status is checked.

    # Create a temp file for Get_Ip_From_Url() to use.
    # -q  -- Fail silently if an error occurs.
    # -t  -- Generate a path in a temp directory (use $TMPDIR if set, else use '/tmp/').
    tempFileNameForGetIp=$(mktemp -q -t "getip.tmp.XXXXXX")
    mktempFileCreationRetVal=$?

    if [ "$mktempFileCreationRetVal" -ne "0" ]; then
        Output_Error_Message "TempFileCreationFailed"
        exit "$ExitStatusErrorTempFileCreationFailed"
    fi

    # If verbose is set and in either multi or fast mode.
    if [ "$verbose" = "TRUE" -a "$operationModeIsMultiOrFast" = "TRUE" ]; then
        echo ""
        echo "Trying: $url"
    fi

    # If in check mode or verbose is set then time the url download.
    if [ "$timeIpRetrieval" = "TRUE" ]; then timeStart=$(date +%s.%N); fi

    # Get the url contents, extract IP-like sequences, and remove any duplicates.
    ipAddress=$(Get_Ip_From_Url "$url" "$tempFileNameForGetIp")
    getIpFromUrlRetVal=$?
    
    # Store whether retrieving the IP address timed out or not in $getIpFromUrlTimedOut.
    if [ "$getIpFromUrlRetVal" -eq "0" ]; then
        getIpFromUrlTimedOut="FALSE"
    else
        getIpFromUrlTimedOut="TRUE"
    fi

    # If in check mode or verbose is set then time the url download.
    if [ "$timeIpRetrieval" = "TRUE" ]; then timeStop=$(date +%s.%N); fi

    # If in check mode or verbose is set, calculate the time taken and reduce to 3 decimal places.
    if [ "$timeIpRetrieval" = "TRUE" ]; then
        timeTaken=$(printf "%.3F" $(echo "$timeStop - $timeStart" | bc -l))
    fi

    # Delete the temp file.
    if [ -f "$tempFileNameForGetIp" ]; then rm "$tempFileNameForGetIp"; fi
   
    # Check if $ipAddress contains a single properly formed IP address and assign a readable value
    # to the variable $isIpValid and a message for verbose in $isIpValidVerbose.

    Is_Ip_Address "$ipAddress"
    isIpAddressRetVal=$?

    if [ "$isIpAddressRetVal" -eq "0" ]; then
        isIpValid="VALID_IP"
    elif [ "$isIpAddressRetVal" -eq "1" ]; then
        isIpValid="IP_NOT_RETURNED"
        isIpValidVerbose="server did not return a valid IP address"
    elif [ "$isIpAddressRetVal" -eq "2" ]; then
        isIpValid="IP_NOT_UNIQUE"
        isIpValidVerbose="server returned more than one IP address"
    elif [ "$isIpAddressRetVal" -eq "3" ]; then
        isIpValid="IP_NOT_RETURNED"
        isIpValidVerbose="server did not return a valid IP address"
    elif [ "$isIpAddressRetVal" -eq "4" ]; then
        isIpValid="IP_NOT_RETURNED"
        isIpValidVerbose="server did not return a valid IP address"
    else
        isIpValid="IP_NOT_RETURNED"
    fi

    # If verbose is set and in either multi or fast mode.
    if [ "$verbose" = "TRUE" -a "$operationModeIsMultiOrFast" = "TRUE" ]; then
    
        if [ "$isIpValid" = "VALID_IP" ]; then
            echo "Source returned a valid IP address: $ipAddress"
        else
            if [ "$getIpFromUrlTimedOut" = "TRUE" ]; then
                echo "Source failed: timeout was exceeded"
            else
                #echo "Source failed: server did not return a valid IP address"
                echo "Source failed: $isIpValidVerbose"
            fi
        fi

        echo "Duration (seconds): $timeTaken"
    fi

    # Code to handle the operation mode: FAST

    # If operating in fast mode and $ipAddress contains a properly formed IP address, then echo
    # the IP address and exit the script.

    if [ "$operationMode" = "FAST" -a "$isIpValid" = "VALID_IP" ]; then

        if [ "$verbose" = "TRUE" ]; then
            echo ""
            echo "IPv4 address: $ipAddress"
        else
            echo "$ipAddress"
        fi

        exit "$ExitStatusSuccess"
    fi

    # Code to handle the operation mode: MULTI
    
    # If operating in multi mode store valid IP addresses in an array and when the required number
    # of addresses to use for verification have been retrieved use Multi_Ip_Check() to check that
    # all the IPs in the array are the same. If so then verification has been successful and the IP
    # can be echoed and the script can exit, if not then reset the variables and keep going.

    if [ "$operationMode" = "MULTI" -a "$isIpValid" = "VALID_IP" ]; then

        # Add the IP address to the array, and add 1 to the counter.
        multiIpList[$multiIpCounter]="$ipAddress"
        let "multiIpCounter = multiIpCounter + 1"

        # If verbose is set...
        if [ "$verbose" = "TRUE" ]; then
            echo "Adding IP address to multi list: $multiIpCounter of $numIpToUseForMulti"
        fi

        # If the array contains the required number of IP addresses to use for verification.
        if [ "$multiIpCounter" -eq "$numIpToUseForMulti" ]; then

            # Check if all the IP addresses in the array are the same.
            Multi_Ip_Check "${multiIpList[@]}"
            multiIpCheckRetVal=$?

            # If verbose is set...
            if [ "$verbose" = "TRUE" ]; then
                echo ""
                if [ "$multiIpCheckRetVal" -eq "0" ]; then
                    echo "The multi mode verification process succeeded, the $multiIpCounter IP"
                    echo "addresses retrieved from the $multiIpCounter web sources are the same."
                else
                    echo "The multi mode verification process failed, the web sources did not"
                    echo "all provide the same IP address. The script will now discard the IP"
                    echo "addresses already returned and try again using different sources. It is"
                    echo "likely that at least one source is no longer functioning properly. You"
                    echo "should use the -c switch to check the sources, and/or download the"
                    echo "newest version of this script, see: getip -h"
                fi
            fi

            # If all the IP addresses in the array are the same, echo the IP address and exit the
            # script. If not then reset both the array and counter to start again.
            if [ "$multiIpCheckRetVal" -eq "0" ]; then

                if [ "$verbose" = "TRUE" ]; then
                    echo ""
                    echo "IPv4 address: $ipAddress"
                else
                    echo "$ipAddress"
                fi
                exit "$ExitStatusSuccess"

            else
                unset multiIpList
                multiIpCounter="0"
            fi
        fi
    fi

    # Code to handle the operation mode: CHECK

    # If operating in check mode calculate the time taken to get the IP address, and then neatly
    # echo the retrieval time, source url, and the IP address.
    
    if [ "$operationMode" = "CHECK" ]; then

        # awk expression for 'pretty printing' the test results.
        awkExprPrettyPrint='{ printf "%-8s %-52s %s\n", $1, $2, $3 }'

        # Pretty print the information in neat columns: time, url, IP.
        if [ "$isIpValid" = "VALID_IP" ]; then
            echo "$timeTaken" "$url" "$ipAddress" | awk "$awkExprPrettyPrint"
        else
            if [ "$getIpFromUrlTimedOut" = "TRUE" ]; then
                echo "$timeTaken" "$url" "TIMED_OUT" | awk "$awkExprPrettyPrint"
            else
                #echo "$timeTaken" "$url" "URL_NO_VALID_IP" | awk "$awkExprPrettyPrint"
                echo "$timeTaken" "$url" "$isIpValid" | awk "$awkExprPrettyPrint"
            fi
        fi
        
        # Add info. to the stored statistics for displaying at the end.
        Add_To_Stats "$ipAddress" "$isIpValid" "$timeTaken"
    fi

done  # End of loop through $urlList loop.

# If operating in multi or fast mode, then if this section of the script is reached then the
# script failed to supply a valid IP address. This would typically indicate that web access is
# currently unavailable.
if [ "$operationModeIsMultiOrFast" = "TRUE" ]; then
    echo "FAILED"
    exit "$ExitStatusErrorMultiOrFastModeGettingIpFailed"
fi

# If operating in check mode, then display the check mode statistics.

if [ "$operationMode" = "CHECK" ]; then

    # Write an error message if all the urls failed.
    if [ "$statsTotalInValidIp" -eq "$urlListLength" ]; then 
        Output_Error_Message "CheckModeAllUrlsFailed"
        exit "$ExitStatusErrorCheckModeAllUrlsFailed"
    fi

    # Display the stats info.
    Display_Stats
fi

# The exit point of the script in check mode.
exit "$ExitStatusSuccess"


##
## END OF SCRIPT.
##

