#!/bin/bash

#
# Name:             getip
# Description:      Script to retrieve an external IPv4 address from IP providing web sites.
# Requirements:     UNIX/Linux, Bash, either curl or wget.
# Usage:            getip [-g | -c | -u url] [-n num_sources] [-t timeout_secs] [-b] [-v] [-h]
# Exit Status:      0 on success, and non-zero on failure.
# Author:           mattst@i-dig.info
# Version:
# Homepage:         https://github.com/mattst/getip
# License:          GNU General Public License v3 - http://www.gnu.org/copyleft/gpl.html
#
#
# The complete list of all utilities and Bash shell commands used by the getip script:
#
# awk, bc, curl, date, disown, echo, exit, getopts, grep, hash, kill, man, mktemp, printf, ps,
# $RANDOM, read, rm, sed, sort, tr, uniq, unset, wc, wget. [wget or curl required, not both.]
#
# With the exception of wget and curl all of the above utilities and commands are expected to exist
# on all modern UNIX like operating systems. If neither wget nor curl are installed the script will
# advise the user to install one of them.
#
#
# Description:
#
# getip is a script used to retrieve an external IPv4 address from behind a router using web sites
# which provide the IP address in plain text or HTML. Note: IPv4 only, not IPv6.
#
# getip echoes the IP address so that it is displayed in the shell or so that it can be stored in a
# variable if getip is called from within another script.
#
# Command line options (all optional):
#
# -m           MULTI; get the IP from multiple sources and check they are all the same (default).
# -f           FAST; get the IP from just one source in order to echo it more quickly than multi.
# -c           CHECK; display the IP address returned by all the web sources and show stats.
# -u url       TEST; test an url for possible inclusion in the source urls and show info.
# -n number    Set the NUMBER of sources to use for verification in multi mode. Range >=2 and <=5.
# -t seconds   Set the TIMEOUT for each source. Real numbers are permitted (e.g. '1.5', '0.75').
# -b           Bare output; display only the IP address and not the "IPv4 address:" prefix.
# -v           VERBOSE; output information while the script is running.
# -h, --help   HELP; output program usage and help.
#
# Multi mode is the default mode so -m is not needed on the command line. The default number of
# sources to use in multi mode is 2.
#
#
# The 4 operation modes: MULTI, FAST, CHECK, and TESTURL.
#
# In both multi and fast modes the list of web sources (the list of web sites which provide your IP
# address) is randomized before use so that no source is used more often than any other. Note: the
# time taken to shuffle the list is negligible.
#
# From time to time a web page used as a source will stop providing IP addresses, either temporarily
# or permanently, but an example IP address might remain on the page, or an IP-like software version
# number might be present on the page (embedded within the HTML) and which could be mistaken for a
# real IP address. In such circumstances an IP address fetching script could provide a user with an
# incorrect IP address. getip uses multi mode by default which fetches the IP address from more than
# one source (2 by default) and makes sure they are the same. Users are advised to use multi mode.
#
#
# MULTI (default mode)   - Command line switches: -m and/or -n number_of_sources
#                        - No switch necessary, MULTI mode is used by default.
#
# In multi mode getip will retrieve the IP address from more than one source and check that all
# sources have supplied the same IP address. The default number of sources to use is 2 but this can
# be set on the command line with -n num where the range of values is >=2 and <=5. Note that the
# default is considered to be sufficient due to the unlikelihood of 2 sources both providing the
# same incorrect IP address. [Using 3 would be over-cautious, 5 in a state of paranoia.]
#
#
# FAST                   - Command line switch: -f
#
# In fast mode getip will retrieve the IP address from just one source with no verification. It is
# generally faster, though not guaranteed to be. It is suggested that fast mode only be used when a
# user already knows their IP address and is seeking confirmation of it, for instance if checking
# whether a connection to a VPN has finished or succeeded. Fast mode should never be used when
# calling getip from within another script.
#
#
# CHECK                  - Command line switch: -c
#
# In check mode getip will display a table in the shell of all the web sources, the IP address which
# was retrieved from the source, or a message of failure, and the time taken to retrieve the IP
# address. In addition it displays some statistics at the end. It can be used by users to check that
# all the sources are functioning correctly. getip will continue to function perfectly adequately
# with even 25% of the sources down. If more than 15% are down you may wish to download the latest
# version of the script or manually delete sources which aren't working from the list below.
#
#
# TESTURL                - Command line switch: -u url
#
# In test url mode getip will test the url to see if it is suitable for adding to the source list.
# getip will display a small table showing the url's status; whether the Url successfully returned a
# single valid IP address, or failed by supplying more than one valid IP address, no IP address at
# all, or if the timeout was exceeded. Only experienced users should use this feature to add an url
# to the source list. If you do use this to find a new url that is suitable for inclusion please
# contact the developer with the url.
#
#
# The other command line options:
#
# NUMBER OF SOURCES      - Command line switch: -n num_sources [Default 2, range: >=2 and <=5.]
#
# Sets the number of sources to use in the multi operation mode.
#
#
# TIMEOUT, FOR EACH SOURCE   - Command line switch: -t seconds
#                            - Range >=0.2 and <=30. [Real numbers are permitted.]
#                            - Default timeout in multi mode:    1.0
#                            - Default timeout in fast mode:     0.75
#                            - Default timeout in check mode:    10.0
#                            - Default timeout in test url mode: 10.0
#
# Sets the timeout in seconds for each source, not an overall timeout for the script. When a source
# gives no response or is slow to respond, getip simply moves on to the next source in the sources
# list. Each of the operation modes has its own default timeout (shown above). The allowed range is
# large, >=0.2 and <=30, as large variations in speed of web access and the user's physical location
# both mean a flexible timeout is sensible, however values less than 0.75 or greater than 3 are not
# usually advisable in multi or fast mode. In check and test url modes a high timeout facilitates
# checking whether sources are functioning at all or not.
#
# There is no 'global' timeout feature for getip, however the timeout multiplied by the number of
# sources means there is a de facto 'global' timeout.
#
#
# BARE                   - Command line switch: -b
#
# Turn bare output on - the script will display only the IP address and not the "IPv4 address:"
# prefix.
#
#
# VERBOSE                - Command line switch: -v
#
# Turns verbose on - the script will output diagnostic information while it runs.
#
#
# HELP                   - Command line switch: -h or --help
#
# Outputs program usage and help then exits.
#


##
## START OF SCRIPT.
##


# Principal Variables.

# Holds the script version number.
version="0.9c"

# Holds the url of the list of the web pages used to retrieve the IP address from.
sourceUrlsListUrl="https://crius.feralhosting.com/gencon/SourceUrlsList"

# Holds the minumum number of source urls that are required.
sourceUrlsMinimum="15"

# Array which holds the urls from $sourceUrlsListUrl - the array is populated below.
urlArray=""

# The number of urls in $urlArray, set below.
urlArrayLength="0"


# $operationMode holds the operation mode, default 'GETIP'.
# Possible values: 'GETIP', 'CHECK', or 'TESTURL'.
operationMode="GETIP"

# Sets the default number of sources to use in GETIP mode. Recommended: 2 (Not: < 2 or > 5).
numIpToUseForGetIP="2"

# Set the default timeout in seconds for the retrieval of each source. A different default timeout
# can be set for each mode. Timeouts may be fractions of a second, e.g. 1.5, 0.75, .75

# GETIP mode: keep the timeout low so that if a source is offline or slow to respond the script
# can move on to the next source. Recommended: 0.75 to 3.0.
timeoutGetIPMode="1"

# CHECK mode: set the timeout high to give the url a chance to succeed. Recommended: 10.
timeoutCheckMode="10"

# TESTURL mode: set the timeout high to give the url a chance to succeed. Recommended: 10.
timeoutTestUrlMode="10"

# Web url of source to test in TESTURL mode.
testUrlAddress=""

# Flag variable to hold if the user has set the number of source IPs to use (the -n option).
userSetNumIpToUseForGetIP="FALSE"

# Flag variable to hold if the user has set a timeout (the -t option).
userSetTimeout="FALSE"

# Flag variable to hold if the user has set the bare output option (the -b option).
bareOutput="FALSE"

# Flag variable to hold if the user has turned on verbose reporting (the -v option).
verbose="FALSE"

# Counter to count how many modes the user set on the command line. Since only 1 mode can be set
# this facilitates checking the user has not inadvertently set more than 1 mode.
userSetModesCounter="0"

# Constants to hold the various exit statuses of the script.
# Careful using ST's InsertNums here, success must be 0 not 1.
ExitStatusSuccess="0"
ExitStatusErrorUrlArgInvalid="1"
ExitStatusErrorNumSourcesArgInvalid="2"
ExitStatusErrorTimeoutArgInvalid="3"
ExitStatusErrorOptionInvalid="4"
ExitStatusErrorArgMissing="5"
ExitStatusErrorUserSetMoreThanOneMode="6"
ExitStatusErrorUserSetVerboseAndBare="7"
ExitStatusErrorWgetAndCurlNotInstalled="8"
ExitStatusErrorDownloadWebSourceListFailed="11"
ExitStatusErrorNotEnoughSourceUrls="9"
ExitStatusErrorTempFileCreationFailed="10"
ExitStatusErrorFailedToGetIPAddress="12"
ExitStatusErrorCheckModeAllUrlsFailed="13"

# Constants to hold the various values returned by the Get_Ip_From_Url() function.
GetIpSingleValidIP="0"
GetIpNoValidIP="1"
GetIpMultipleValidIP="2"
GetIpTimedOut="3"

# Set the user agent to use for web page downloads. The script does not try to hide that it is a
# script. The user agent header is modelled on the one used by Google's 'googlebot':
# Googlebot 2.1: "Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)"
userAgent="Mozilla/5.0 (compatible; getipscript/$version; +https://github.com/mattst/getip)"


# Function which sends the various error messages to STDERR.
Output_Error_Message()
{
    # Assign $errToDisplay the value of the 1st function arg (NOT script arg).
    local errToDisplay=$1

    # Assign $additionalInfo the value of the 2nd function arg (NOT script arg).
    # Some errors display a configurable piece of information, e.g. an option.
    local additionalInfo=$2

    # Output the appropriate error message to STDERR.

    if [ "$errToDisplay" = "ArgInvalid" ]; then
        echo "The argument given to the $additionalInfo option is invalid." >&2

    elif [ "$errToDisplay" = "OptionInvalid" ]; then
        echo "An invalid option has been entered." >&2

    elif [ "$errToDisplay" = "ArgMissing" ]; then
        echo "The argument is missing for the option: -$additionalInfo" >&2

    elif [ "$errToDisplay" = "UserSetMoreThanOneMode" ]; then
        echo "Only one operation mode can be used at a time." >&2

    elif [ "$errToDisplay" = "UserSetVerboseAndBare" ]; then
        echo "Verbose and bare output can not be used at the same time." >&2

    elif [ "$errToDisplay" = "TempFileCreationFailed" ]; then
        echo "Unable to create a temp file using 'mktemp'." >&2

    elif [ "$errToDisplay" = "DownloadWebSourceListFailed" ]; then
        echo "Unable to download the list of web sources from:" >&2
        echo "$sourceUrlsListUrl" >&2

    elif [ "$errToDisplay" = "NotEnoughSourceUrls" ]; then
        echo "Not encough web sources urls, the minimum required is $sourceUrlsMinimum." >&2

    elif [ "$errToDisplay" = "FailedToGetIPAddress" ]; then
        echo "The script failed to get the IP address." >&2

    elif [ "$errToDisplay" = "WgetAndCurlNotInstalled" ]; then
        echo "The getip script requires either 'wget' or 'curl' to access the web, please" >&2
        echo "install one of them in order to use this script. wget and curl are both" >&2
        echo "programs that can retrieve web pages, and they are widely available for all" >&2
        echo "UNIX/Linux based systems. The getip script works equally well with either." >&2
    fi

    echo "" >&2
    echo "Use \"getip -h\" for usage and help." >&2
}

# Test error messages:
# Output_Error_Message "ArgInvalid" "-u"
# Output_Error_Message "OptionInvalid"
# Output_Error_Message "ArgMissing" "t"
# Output_Error_Message "UserSetMoreThanOneMode"
# Output_Error_Message "UserSetVerboseAndBare"
# Output_Error_Message "TempFileCreationFailed"
# Output_Error_Message "DownloadWebSourceListFailed"
# Output_Error_Message "FailedToGetIPAddress"
# Output_Error_Message "WgetAndCurlNotInstalled"
# exit 0


# Display help by redirecting the text of the man page to a temp file and displaying it using man.
Display_Usage_Message()
{
    # Create a temp file to store the man page here document.
    # Don't use 'local' for 'tempFileNameForGetIpManPage' or $? won't work.
    tempFileNameForGetIpManPage=$(mktemp -q -t "getip.man.tmp.XXXXXX")
    local mktempFileCreationRetVal=$?

    if [ "$mktempFileCreationRetVal" -ne "0" ]; then
        Output_Error_Message "TempFileCreationFailed"
        exit "$ExitStatusErrorTempFileCreationFailed"
    fi

# Output a here document of the getip man page to $tempFileNameForGetIpManPage.
# Here documents won't work well with indentation, keep to the hard left.
cat >>$tempFileNameForGetIpManPage <<EOF

.TH GETIP 1 "29 Sep 2015" "1.0" "GETIP VERSION 1.0"

.SH NAME

getip \- retrieves the WAN IP address

.SH SYNOPSIS

getip [-m | -f | -c | -u url] [-n num_sources] [-t timeout_secs] [-v] [-h]

.SH REQUIREMENTS

The BASH shell and either wget or curl must be installed. Most modern UNIX like systems come with BASH and wget pre-installed. wget and curl are both programs which download pages from the web. getip works equally well with them both. wget is used by default if both are installed on the system.

.SH DESCRIPTION

getip is a BASH script used to retrieve the WAN IP address from behind a router using web sites (sources) which provide the IP address in plain text or HTML.

From time to time a web page used as a source will stop providing IP addresses, either temporarily or permanently, but an example IP address might remain on the page, or an IP-like software version number might be present, embedded in the HTML, and which could be mistaken for a real IP address (although the script tries hard to spot version numbers so they can be ignored). In such cases an IP address fetching script could provide a user with an incorrect IP address. getip uses multi mode by default to prevent this from happening.

In multi mode the IP address is retrieved from multiple sources (default: 2) and compared, so that the correct IP address can be provided. Users are advised to use multi mode in preference to fast mode.

The getip script retrieves IPv4 addresses only and not IPv6 addresses.

This script currently contains over 100 web sources.

The list of web sources is randomized every time the script is run. This is so that undue pressure is not placed on servers near the top of the list. The randomizing process is done very quickly and does not have a significant impact on the running time of the script.

.SH OPTIONS
.BR
In typical usage no options are necessary.
.BR

.TP
\fB\-m\fR
Multi mode (default); fetch the IP address from multiple sources and check that they are all the same. In multi mode the default number of sources to use is 2. This is the default mode so \fB\-m\fR is optional. See: \fB\-n\fR \fBnum_sources\fR

.TP
\fB\-f\fR
Fast mode; fetch the IP address from just one source in order to retrieve it more quickly than in multi mode. Fast mode is not guaranteed to be faster than multi mode but on average it will be slightly faster. It is advisable that users only use fast mode to confirm their IP address when it is already known, e.g. checking a VPN connection. In some circumstances an incorrect IP address can be returned in fast mode, see \fBDescription\fR section above.

.TP
\fB\-c\fR
Check mode; displays a table containing the url of each source, the IP address that it returned (or a failure message), the time taken to retrieve the IP address, and various statistics. Used to test the sources list.

.TP
\fB\-u\fR \fBurl\fR
Test Url mode; tests an url for inclusion in the sources list. It will display whether the url returned a single IP address (which is required for inclusion in the sources list), multiple IP addresses, or no IP addresses at all. To aid debugging it will list all IP addresses returned.

.TP
\fB\-n\fR \fBnum_sources\fR
Sets the Number of sources to use in multi mode. The allowed range of values is >=2 and <=5. The default value is 2.

.TP
\fB\-t\fR \fBnum_seconds\fR
Sets the Timeout for each source. This is not an overall timeout for the script. When a source gives no response or is slow to respond, getip moves on to the next source and this is the timeout in seconds for each one. Note: Real numbers are permitted, e.g. 0.75, 1.5, .85, etc. The allowed range of values is >=0.2 and <=30 (but these extremes are overkill).

The default timeouts are dependant on mode, in seconds they are; multi mode 1, fast mode 0.75, check mode 10, test url mode 10.

.TP
\fB\-b\fR
Bare output; display only the IP address and not the "IPv4 address:" prefix.

.TP
\fB\-v\fR
Verbose; display detailed information while the script runs.

.TP
\fB\-h\fR, \fB\-\-help\fR
Help; display usage and help.

.TP
\fB\-\-version\fR
Display version number.

.SH EXIT STATUS
getip returns 0 on success, and non-zero on failure.

.SH BUGS
No known bugs.

.SH HOMEPAGE
https://github.com/mattst/getip
.LP
Feel free to submit new IP address providing web pages to be added to the sources list.

.SH AUTHOR
<mattst@i-dig.info>
EOF

    # Display the man page.
    man "$tempFileNameForGetIpManPage"

    # Delete the temp file.
    if [ -f "$tempFileNameForGetIpManPage" ]; then rm "$tempFileNameForGetIpManPage"; fi
}


# Before handling the arguments with getopts, check for long options:

# Check if the first arg is "--help", if so display help and exit (-h is handled by getopts).
if [ "$1" = "--help" -o "$1" = "-?" ]; then
    Display_Usage_Message
    exit "$ExitStatusSuccess"

# Check if the first arg is "--version", if so display version number and exit.
elif [ "$1" = "--version" ]; then
    echo "getip v. $version"
    exit "$ExitStatusSuccess"
fi

# Use getopts to handle the command line arguments. ToDo: Add long option support.
while getopts ":gcu:bvhn:t:" option; do

    case $option in

        g)
            # -g has been used, set operation mode to GETIP.
            operationMode="GETIP"
            let "userSetModesCounter = userSetModesCounter + 1"
            ;;

        c)
            # -c has been used, set operation mode to CHECK.
            operationMode="CHECK"
            let "userSetModesCounter = userSetModesCounter + 1"
            ;;

        u)
            # -u url has been used, set operation mode to TESTURL and set the url address.
            operationMode="TESTURL"
            testUrlAddress="$OPTARG"
            let "userSetModesCounter = userSetModesCounter + 1"

            # Check if $testUrlAddress is an url by seeing if the first 4 chars are 'http'.
            urlFirst4Chars=${testUrlAddress:0:4}
            urlFirst4CharsLowerCase=$(echo "$urlFirst4Chars" | tr '[:upper:]' '[:lower:]')

            if [ "$urlFirst4CharsLowerCase" != "http" ]; then
                Output_Error_Message "ArgInvalid" "-u"
                exit "$ExitStatusErrorUrlArgInvalid"
            fi
            ;;

        b)
            # -b has been used, turn on bare output.
            bareOutput="TRUE"
            ;;

        v)
            # -v has been used, turn on verbose.
            verbose="TRUE"
            ;;

        h)
            # -h has been used, display help and then exit.
            Display_Usage_Message
            exit "$ExitStatusSuccess"
            ;;

        n)
            # -n num has been used, set the num source IPs to use and flag variable.
            numIpToUseForGetIP="$OPTARG"
            userSetNumIpToUseForGetIP="TRUE"

            # Use sed to check that $numIpToUseForGetIP is a single digit >=2 and <=5.
            numMin="2"
            numMax="5"

            sedExpIsNumInRange="s/^[$numMin-$numMax]\{1\}$/SINGLE_DIGIT_IN_RANGE/g"
            isNumInRange=$(echo "$numIpToUseForGetIP" | sed "$sedExpIsNumInRange")

            # A single digit in range has not been entered.
            if [ "$isNumInRange" != "SINGLE_DIGIT_IN_RANGE" ]; then
                Output_Error_Message "ArgInvalid" "-n"
                exit "$ExitStatusErrorNumSourcesArgInvalid"
            fi
            ;;

        t)
            # -t seconds has been used, set the timeout flag and arg variables.
            timeoutSecondsArg="$OPTARG"
            userSetTimeout="TRUE"

            # Check that $timeoutSecondsArg is a number, int or real. This is a Bash hack to use
            # awk to check whether a variable is any kind of number (int or real).
            awkIsNum='END { if ($1 + 0 == $1) print "Num"; else print "NotNum" }'
            awkIsNumRetVal=$(echo "$timeoutSecondsArg" | awk "$awkIsNum")

            if [ "$awkIsNumRetVal" = "NotNum" ]; then
                Output_Error_Message "ArgInvalid" "-t"
                exit "$ExitStatusErrorTimeoutArgInvalid"
            fi

            # Check that $timeoutSecondsArg is a positive number in range, >=0.2 and <=30.
            timeoutMin="0.2"
            timeoutMax="30"

            bcExpIsNumInRange="if ($timeoutSecondsArg < $timeoutMin || \
                                   $timeoutSecondsArg > $timeoutMax) 1 else 0"

            bcExpIsNumInRangeRetVal=$(echo "$bcExpIsNumInRange" | bc -l)

            # A positive number in range has not been entered.
            if [ "$bcExpIsNumInRangeRetVal" -eq "1" ]; then
                Output_Error_Message "ArgInvalid" "-t"
                exit "$ExitStatusErrorTimeoutArgInvalid"
            fi
            ;;

        \?)
            # User entered an invalid option, e.g. '-x'. Note: Invalid args with no '-' prefix,
            # are handled immediately after this while loop.
            Output_Error_Message "OptionInvalid"
            exit "$ExitStatusErrorOptionInvalid"
            ;;

        :)
            # User omitted the required additional arg of either the, -u, -n or -t option.
            Output_Error_Message "ArgMissing" "$OPTARG"
            exit "$ExitStatusErrorArgMissing"
            ;;
    esac
done


# getopts stops processing args if it encounters an arg without a '-' prefix (unless it is an
# $OPTARG in which case processing continues). Check if any invalid args have been entered by
# working out how many args getopts has actually processed, shifting them off, and if more
# than 0 args remain then an invalid arg must have been entered.

let "numArgsProcessedByGetopts = OPTIND - 1"
shift "$numArgsProcessedByGetopts"
numArgsRemaining="$#"

if [ "$numArgsRemaining" -gt "0" ]; then
    Output_Error_Message "OptionInvalid"
    exit "$ExitStatusErrorOptionInvalid"
fi

# If the user set more than 1 mode on the command line, display error and exit.
if [ "$userSetModesCounter" -gt "1" ]; then
    Output_Error_Message "UserSetMoreThanOneMode"
    exit "$ExitStatusErrorUserSetMoreThanOneMode"
fi

# Set the appropriate timeout.

# If the user set the timeout use that otherwise use the default.
if [ "$userSetTimeout" = "TRUE" ]; then
    timeout="$timeoutSecondsArg"
else
    if [ "$operationMode" = "GETIP" ]; then
        timeout="$timeoutGetIPMode"
    elif [ "$operationMode" = "CHECK" ]; then
        timeout="$timeoutCheckMode"
    elif [ "$operationMode" = "TESTURL" ]; then
        timeout="$timeoutTestUrlMode"
    fi
fi

# If the user has set both verbose and bare output, display error and exit.
if [ "$verbose" = "TRUE" -a "$bareOutput" = "TRUE" ]; then
    Output_Error_Message "UserSetVerboseAndBare"
    exit "$ExitStatusErrorUserSetVerboseAndBare"
fi

# Either wget or curl can be used to download the source urls.
# $urlDownloadProgram will hold which to use, either: 'WGET' or 'CURL'.

# Set the default download program (which to use if both are installed).
# urlDefaultDownloadProgram="CURL"
urlDefaultDownloadProgram="WGET"

# Check whether wget and curl are installed, at least one is required.
hash wget > /dev/null 2>&1
isWgetInstalled=$?
hash curl > /dev/null 2>&1
isCurlInstalled=$?

# Decide whether to use wget or curl for web page downloading.

# If both wget and curl are installed, use the default.
if [ "$isWgetInstalled" -eq "0" -a "$isCurlInstalled" -eq "0" ]; then
    urlDownloadProgram="$urlDefaultDownloadProgram"

# If only wget is installed, use that.
elif [ "$isWgetInstalled" -eq "0" -a "$isCurlInstalled" -ne "0" ]; then
    urlDownloadProgram="WGET"

# If only curl is installed, use that.
elif [ "$isCurlInstalled" -eq "0" -a "$isWgetInstalled" -ne "0" ]; then
    urlDownloadProgram="CURL"

# If neither wget nor curl are installed, display error and exit.
else
    Output_Error_Message "WgetAndCurlNotInstalled"
    exit "$ExitStatusErrorWgetAndCurlNotInstalled"
fi

# If verbose is set, echo various diagnostic information.
if [ "$verbose" = "TRUE" -a "$operationMode" != "TESTURL" ]; then

    printf "%-25s %s\n" "Script Version:" "$version"
    printf "%-25s %s\n" "Operation Mode:" "$operationMode"

    if [ "$operationMode" = "GETIP" ]; then
        printf "%-25s %s\n" "Num IP Sources (To Use):" "$numIpToUseForGetIP"
    fi

    printf "%-25s %s\n" "Timeout (Seconds):" "$timeout"
    printf "%-25s %s\n" "Download Utility:" "$urlDownloadProgram"
fi


# Fetch the web sources list from $sourceUrlsListUrl and store them in the $urlArray array.

# Create a temp file to store the online source url list file in.
tempFileNameForSourceUrls=$(mktemp -q -t "getip.sourceurls.tmp.XXXXXX")
mktempFileCreationRetVal=$?

if [ "$mktempFileCreationRetVal" -ne "0" ]; then
    Output_Error_Message "TempFileCreationFailed"
    exit "$ExitStatusErrorTempFileCreationFailed"
fi

# Use wget to download the source url list file.
if [ "$urlDownloadProgram" = "WGET" ]; then

    wget --quiet --tries=1 --user-agent="$userAgent" --output-document=- \
         "$sourceUrlsListUrl" > "$tempFileNameForSourceUrls"
    wgetDownloadSourceUrlsListRetVal=$?

    if [ "$wgetDownloadSourceUrlsListRetVal" -ne "0" ]; then
        Output_Error_Message "DownloadWebSourceListFailed"
        exit "$ExitStatusErrorDownloadWebSourceListFailed"
    fi

# Use curl to download the source url list file.
elif [ "$urlDownloadProgram" = "CURL" ]; then

    curl --silent --user-agent "$userAgent" "$sourceUrlsListUrl" > "$tempFileNameForSourceUrls"
    curlDownloadSourceUrlsListRetVal=$?

    if [ "$curlDownloadSourceUrlsListRetVal" -ne "0" ]; then
        Output_Error_Message "DownloadWebSourceListFailed"
        exit "$ExitStatusErrorDownloadWebSourceListFailed"
    fi
fi

# Read the urls from the source urls temp file into the $urlArray. Note: The Randomize_Url_List()
# function needs the url array to be INDEXED IN NUMERICAL SEQUENCE FROM 0 or it will not randomize
# the array correctly.

urlIndex="0"

while read -r line ; do

    # Check if $line is an url by seeing if the first 4 chars are 'http'.
    lineFirst4Chars=${line:0:4}
    lineFirst4CharsLC=$(echo "$lineFirst4Chars" | tr '[:upper:]' '[:lower:]')

    # If so add the url in $line to $urlArray.
    if [ "$lineFirst4CharsLC" = "http" ]; then
        urlArray[$urlIndex]="$line"
        let 'urlIndex = urlIndex + 1'
    fi

done < "$tempFileNameForSourceUrls"

# Set the length of the urlArray array (indexed from 0).
urlArrayLength="$urlIndex"

# Delete the temp file.
if [ -f "$tempFileNameForSourceUrls" ]; then rm "$tempFileNameForSourceUrls"; fi

# If verbose is set, echo various diagnostic information.
if [ "$verbose" = "TRUE" -a "$operationMode" = "GETIP" ]; then
    printf "%-25s %s\n" "Source Urls Download:" "Succeeded"
    printf "%-25s %s\n" "Source Urls Total:" "$urlArrayLength"
fi

# Check if the number of source urls is fewer than the required minimum.
if [ "$urlArrayLength" -lt "$sourceUrlsMinimum" ]; then
    Output_Error_Message "NotEnoughSourceUrls"
    exit "$ExitStatusErrorNotEnoughSourceUrls"
fi


# Function that randomizes the $urlArray array. Since this script is being publicly released it is
# sensible to randomize the sources so as not to place undue pressure on any one server. This is
# an implementation of the Knuth shuffle algorithm (aka Fisher-Yates shuffle), which is a very
# efficient randomizer, needing just one pass through an array, so time complexity is: O(n)
# Get more information on the Knuth shuffle here: http://en.wikipedia.org/wiki/Knuth_shuffle
# IMPORTANT: THE $urlArray ARRAY MUST BE INDEXED IN NUMERICAL SEQUENCE FROM 0 FOR THIS FUNCTION.
Randomize_Url_List()
{
    # Bash $RANDOM provides a random number in the range 0..32767 so 32768 possible values.
    local randMax="32768"

    # Start at the number of items in the array (i.e. final element's index + 1).
    local index="$urlArrayLength"

    # Loop down through the array randomly swapping the current element with another randomly
    # chosen element (possibly itself). The use of >1 needs a moment to understand... if instead
    # it was > 0 then the final iteration would always swap index 0 with itself.
    while [ "$index" -gt "1" ]; do

        # Modulo bias avoidance as per Knuth shuffle algorithm description. Use bc to calculate the
        # highest usable random number so that the modulo by index calculation will not result in
        # any modulo bias. [scale=0 means integer arithmetic, the division will be rounded down.]

        local bcExpHighestAcceptableRandNum="scale=0; (($randMax / $index) * $index) - 1"
        local highestAcceptableRandNum=$(echo "$bcExpHighestAcceptableRandNum" | bc)

        # Get a random number within the modulo bias avoidance range.
        local randNum="$RANDOM"
        while [ "$randNum" -gt "$highestAcceptableRandNum" ]; do
            randNum="$RANDOM"
        done

        # Force the random number into the range 0..index-1.
        let "randIndex = randNum % index"

        # Decrement index to reference the current 'last' element in the array. For the first loop
        # iteration index will be $urlArrayLength - 1 (the final element of the array) and for the
        # last loop iteration index will be 1. By doing so the current index will be swapped with
        # a randomly chosen index ($randIndex) in the range 0..index, so elements will sometimes
        # be 'swapped' with themselves (if no elements could stay put it wouldn't be random).

        let "index = index - 1"
        local tempUrl=${urlArray[$index]}
        urlArray[$index]=${urlArray[$randIndex]}
        urlArray[$randIndex]=$tempUrl

    done
}


# Function to extract valid IP addresses from the file path given in the 1st function arg. As
# output it echos a list of valid IP addresses seperated by newlines for capture in a variable
# at the point of function invocation.
Extract_Ip_Addresses_From_File()
{
    # Assign $fileName the value of the 1st function arg (NOT script arg). The function will
    # extract valid IP addresses from the file $fileName which will be the temp file used to
    # store the contents downloaded from the web sources.
    local fileName="$1"

    # The following Awk program will search for and print all valid IP addresses in the file
    # which is given to it as input.

    # The regex ipLikeSequence deliberately matches IP address like sequences which are too long
    # to be a valid IP so that the regex does not examine something like '63.27.11.34.98' and
    # match just the '63.27.11.34' section of it, and in so doing cause something that is
    # definitely not an IP address to get mistaken for a valid one. IP address like sequences
    # are checked in the END section to make sure they have exactly 4 segments, separated by
    # dots (".") and that each of the 4 numbers are within the 0..255 range of a valid IP.

    # The regex digitSequenceTooLongNotIP will match sequences of numbers which are longer than
    # 3 digits. There are all removed as they can not possibly be part of an IP address.

    # The regex versioningNotIP attempts to spot version numbers which happen to be in the same
    # format as an IP address (which they are often are). e.g. Version 1.2.0.12
    # Any ipLikeSequence which follows words like "Version", "Ver", or "V", will be removed.

    # Version numbers are also often embedded in an url like "1.6.1.0" in these examples:
    # e.g. <script language="JavaScript" src="http://web.com/libs/1.6.1.0/file.js"></script>
    # e.g. <script language="JavaScript" src="http://web.com/libs/v.1.6.1.0/file.js"></script>
    # The regexes beginsWithFwdSlashNotIP and endsWithFwdSlashNotIP match an ipLikeSequence which
    # begins or ends with a forward slash so that those sequences can be removed.

    local awkExtractIPAddresses='
    BEGIN {
        # Regex to match an IP address like sequence (even if too long to be an IP). This is
        # deliberately a loose match, the END section will check for IP address validity.
        ipLikeSequence = "[0-9]+[.][0-9]+[.][0-9]+[.][0-9]+[0-9.]*";

        # Regex to match a number sequence longer than 3 digits.
        digitSequenceTooLongNotIP = "[0-9][0-9][0-9][0-9]+";

        # Regex to match an IP address like sequence which is a version number.
        # Equivalent to "(version|ver|v)[ .:]*" in conjunction with: line = tolower($0);
        versioningNotIP = "[Vv]([Ee][Rr]([Ss][Ii][Oo][Nn])?)?[ .:]*" ipLikeSequence;

        # Regexes to match IP address like sequences next to forward slashes, to avoid version
        # numbers in urls: e.g. http://web.com/libs/1.6.1.0/file.js
        beginsWithFwdSlashNotIP = "[/]" ipLikeSequence;
        endsWithFwdSlashNotIP = ipLikeSequence "[/]";
    }
    {
        # Set line to the current line (more efficient than using $0 below).
        line = $0;

        # Replace sequences on line which will interfere with extracting genuine IPs. Use a
        # replacement char and not the empty string to avoid accidentally creating a valid IP
        # address from digits on either side of the removed sections. Use "/" as the replacement
        # char for the 2 "FwdSlash" regexes so that multiple number dot slash sequences all get
        # removed, as using "x" could result in inadvertently leaving such a sequence in place.
        # e.g. "/lib1.6.1.0/1.2.3.4/5.6.7.8/file.js" would leave "/lib1.6.1.0xx/file.js".

        gsub(digitSequenceTooLongNotIP, "x", line);
        gsub(versioningNotIP, "x", line);
        gsub(beginsWithFwdSlashNotIP, "/", line);
        gsub(endsWithFwdSlashNotIP, "/", line);

        # Loop through the current line matching IP address like sequences and storing them in
        # the index of the array ipUniqueMatches. By using ipMatch as the array index duplicates
        # are avoided and the values can be easily retrieved by the for loop in the END section.
        # match() automatically sets the built in variables RSTART and RLENGTH.

        while (match(line, ipLikeSequence))
        {
            ipMatch = substr(line, RSTART, RLENGTH);
            ipUniqueMatches[ipMatch];
            line = substr(line, RSTART + RLENGTH + 1);
        }
    }
    END {
        # Define some IP address related constants.
        ipRangeMin = 0;
        ipRangeMax = 255;
        ipNumSegments = 4;
        ipDelimiter = ".";

        # Loop through the ipUniqueMatches array and print any valid IP addresses. The awk "for
        # each" type of loop is different from the norm. It provides the indexes of the array
        # and NOT the values of the array elements which is more usual in this type of loop.

        for (ipMatch in ipUniqueMatches)
        {
            numSegments = split(ipMatch, ipSegments, ipDelimiter);
            if (numSegments == ipNumSegments &&
                ipSegments[1] >= ipRangeMin && ipSegments[1] <= ipRangeMax &&
                ipSegments[2] >= ipRangeMin && ipSegments[2] <= ipRangeMax &&
                ipSegments[3] >= ipRangeMin && ipSegments[3] <= ipRangeMax &&
                ipSegments[4] >= ipRangeMin && ipSegments[4] <= ipRangeMax)
            {
                print ipMatch;
            }
        }
    }'

    # Extract valid IP addresses from $fileName, they will each be separated by a new line.
    local awkValidIpAddresses=$(awk "$awkExtractIPAddresses" < "$fileName")

    # Echo $awkValidIpAddresses for capture in a variable at the point of function invocation.
    echo "$awkValidIpAddresses"
}


# Function that retrieves the source's content and returns all unique IP addresses in it. The
# function provides an accurate timeout facility; neither curl nor wget reliably honour any
# timeout value which has been set nor do they allow timeouts in fractions of a second. Since
# getip uses many different sources a low timeout is used, if one source fails to return very
# quickly then the next source is tried. With this methodology a reliable and accurate low
# timeout is required, this function provides it.
Get_Ip_From_Url()
{
    # Assign $urlToDownload the value of the 1st function arg (NOT script arg).
    local urlToDownload="$1"

    # Assign $tempFileName the value of the 2nd function arg (NOT script arg). This will be used
    # to store the contents of the url.
    local tempFileName="$2"

    # Download the url and store its contents in the temp file. The process is forked to facilitate
    # the timeout procedure. The use of disown, which removes a job from the shell's active jobs
    # table, is so that if the process is later killed (which it will be if it times out) then
    # no shell message is displayed.

    # Store the start time for the timeout. Note: %s seconds, %N nanoseconds.
    local timeoutStart=$(date +%s.%N)

    # Use wget to download the url.
    if [ "$urlDownloadProgram" = "WGET" ]; then

        wget --quiet --tries=1 --user-agent="$userAgent" --output-document=- \
             "$urlToDownload" > "$tempFileName" &

        urlDownloadProcessId=$!
    fi

    # Use curl to download the url.
    if [ "$urlDownloadProgram" = "CURL" ]; then

        curl --silent --user-agent "$userAgent" "$urlToDownload" > "$tempFileName" &

        urlDownloadProcessId=$!
    fi

    # For some reason even if kill has both stdout and stderr redirected to /dev/null the death of
    # the process is still output, using disown to remove the job from the shell's active jobs
    # table stops this from happening so there are no unsightly terminal messages.
    disown "$urlDownloadProcessId"

    # The following loop handles the timeout procedure for the url download process. ps is used to
    # see if the download process is still alive. The loop will finish when the process has
    # completed or when the timeout is exceeded.

    local isUrlDownloadDone="FALSE"
    local isUrlDownloadTimedOut="FALSE"

    while [ "$isUrlDownloadDone" = "FALSE" -a "$isUrlDownloadTimedOut" = "FALSE" ]; do

        # Store whether the url download process is still listed by ps.
        ps -e | grep --quiet "$urlDownloadProcessId"
        local processGrepRetVal=$?

        # If the url download process has finished.
        if [ "$processGrepRetVal" -ne "0" ]; then
            isUrlDownloadDone="TRUE"

        # If the url download process has not finished.
        else
            # Store the current time for the timeout. Note: %s seconds, %N nanoseconds.
            local timeoutNow=$(date +%s.%N)

            # Use bc to check if the timeout has been exceeded.
            local bcExpTimeout="if (($timeoutNow - $timeoutStart) > $timeout) 1 else 0"
            local bcExpTimeoutRetVal=$(echo "$bcExpTimeout" | bc -l)

            # The timeout has been exceeded.
            if [ "$bcExpTimeoutRetVal" -eq "1" ]; then
                isUrlDownloadTimedOut="TRUE"
            fi
        fi
    done

    # If the url download process completed sucessfully.
    if [ "$isUrlDownloadDone" = "TRUE" ]; then

        # Use the function Extract_Ip_Addresses_From_File() to extract valid IP addresses from
        # $tempFileName. Each IP address will be separated by a new line but if the source is
        # working as expected then there will be exactly one IP address.
        local ipAddressList=$(Extract_Ip_Addresses_From_File "$tempFileName")

        # Array to hold the IP address or addresses and an associated counter.
        local ipAddressValidArray=""
        local ipAddressValidCounter="0"

        # Iterate through $ipAddressList storing the IP address(es) in the array.
        for validIpAddress in $(echo "$ipAddressList" | tr "\n" " "); do
            ipAddressValidArray[$ipAddressValidCounter]="$validIpAddress"
            let "ipAddressValidCounter = ipAddressValidCounter + 1"
        done

        # If the length of the array is exactly 1 then that is considered to be the user's IP
        # address, it is echoed so that it can be placed in a variable at the point of function
        # invocation, and the constant $GetIpSingleValidIP is returned - success.
        if [ "$ipAddressValidCounter" -eq "1" ]; then
            echo "${ipAddressValidArray[0]}"
            return "$GetIpSingleValidIP"

        # If the array has no members then the constant $GetIpNoValidIP is returned, no valid
        # IP address was found - failure.
        elif [ "$ipAddressValidCounter" -lt "1" ]; then
            return "$GetIpNoValidIP"

        # If the length of the array is more than 1 then the constant $GetIpMultipleValidIP is
        # returned, more than one unique and valid IP address was found, there is no way to tell
        # which of them is the user's IP address - failure.
        elif [ "$ipAddressValidCounter" -gt "1" ]; then
            # If in test url mode then echo all the valid IP addresses that were found so that
            # the test url mode code section can echo them to aid debugging.
            if [ "$operationMode" = "TESTURL" ]; then echo "$ipAddressList"; fi
            return "$GetIpMultipleValidIP"
        fi
    fi

    # If the url download process timed out (which it must have done or this section of the
    # function would not have been reached) then kill the process (and make doubly sure).

    # Since the process being killed has been disowned (removed from the shell's active jobs
    # table) the redirect of stdout and stderr to /dev/null may be unnecessary to hide the kill
    # messages, it is not necessary on the 3 Linux systems used to test the script, other OSes?

    if [ "$isUrlDownloadTimedOut" = "TRUE" ]; then

        kill -INT "$urlDownloadProcessId" > /dev/null 2>&1
        local killRetVal=$?

        if [ "$killRetVal" -ne "0" ]; then
            kill -KILL "$urlDownloadProcessId" > /dev/null 2>&1
        fi
    fi

    # The download process timed out, return the appropriate constant.
    return "$GetIpTimedOut"
}


# Function that checks that all the IP addresses passed to it are exactly the same.
# It is used to check that all the IP addresses retrieved are identical.
Verify_IP_List()
{
    # Assign all the IP addresses passed to this function to the array $ips.
    local ips=("$@")

    # Iterate through the array checking that all the IP addresses are the same.
    for ip in "${ips[@]}"; do

        # If $ip is not the same as the first IP address in the array, return 1.
        if [ "$ip" != "${ips[0]}" ]; then
            return "1"
        fi
    done

    # All the IP addresses in the array must be the same, return 0.
    return "0"
}


# Initiate the various variables used for stats in the check operation mode.
statsValidIpAddressList=""
statsTimesList=""
statsTotalValidIp="0"
statsTotalInValidIp="0"


# Add IP's address, validity, and retrieval time to the statistics variables (used in check mode).
Add_To_Stats()
{
    # Assign the IP address, its validity, and retrieval time to local variables.
    local ipAddressForStats="$1"
    local ipStatusForStats="$2"
    local timeTakenForStats="$3"

    # If the IP address is valid.
    if [ "$ipStatusForStats" = "VALID_IP" ]; then

        # Add the IP address to the list of valid IP addresses. [The trailing space is essential.]
        statsValidIpAddressList+="$ipAddressForStats "

        # Add the time taken to the list of times taken. [The trailing space is essential.]
        statsTimesList+="$timeTakenForStats "

        # Add one to the valid IP address counter.
        let "statsTotalValidIp = statsTotalValidIp + 1"

    # If the IP address is not valid add one to the invalid IP address counter.
    else
        let "statsTotalInValidIp = statsTotalInValidIp + 1"
    fi
}


# Function to find the fastest time from the times in the $statsTimesList list.
Find_Fastest_Time()
{
    # Awk expression to find the fastest time.
    local awkFastest='{ if (NR == 1) fastest = $1; if ($1 < fastest) fastest = $1; } \
                      END { printf("%.3f", fastest) }'

    # Pipe the $statsTimesList to awk to get the fastest time.
    local fastest=$(echo "$statsTimesList" | tr " " "\n" | awk "$awkFastest" )

    # Echo $fastest for capture at point of function invocation.
    echo "$fastest"
}


# Function to find the slowest time from the times in the $statsTimesList list.
Find_Slowest_Time()
{
    # Awk expression to find the slowest time.
    local awkSlowest='{ if (NR == 1) slowest = $1; if ($1 > slowest) slowest = $1; } \
                      END { printf("%.3f", slowest) }'

    # Pipe the $statsTimesList to awk to get the slowest time.
    local slowest=$(echo "$statsTimesList" | tr " " "\n" | awk "$awkSlowest" )

    # Echo $slowest for capture at point of function invocation.
    echo "$slowest"
}


# Function to calculate the mean average of the times in the $statsTimesList list.
Calculate_Mean_Average_Time()
{
    # Awk expression to calculate the mean average.
    local awkMean='{ total = total + $1; } \
                   END { mean = total / numItems; printf("%.3f", mean) }'

    # Pipe the $statsTimesList to awk to get the mean.
    local mean=$(echo "$statsTimesList" | tr " " "\n" |
                 awk "$awkMean" numItems="$statsTotalValidIp")

    # Echo $mean for capture at point of function invocation.
    echo "$mean"
}


# Function to calculate the median average of the times in the $statsTimesList list.
Calculate_Median_Average_Time()
{
    # Establish if there are an even or odd number of times stored in $statsTimesList.
    local medianItemsEvenOrOdd=""
    let 'modTwoOfTotalValidIp = statsTotalValidIp % 2'

    if [ "$modTwoOfTotalValidIp" = "0" ]; then medianItemsEvenOrOdd="EVEN"
    else                                       medianItemsEvenOrOdd="ODD"
    fi

    # If an odd number of items, the median is the middle item in the ordered list.
    if [ "$medianItemsEvenOrOdd" = "ODD" ]; then

        # Work out which is the middle item (integer arithmetic so division will be rounded down).
        local middleItem=""
        let "middleItem = (statsTotalValidIp / 2) + 1"

        # Awk expression to print the middle row which will be the median value.
        local awkMedianOdd='{ if (NR == midRow) printf("%.3f", $1) }'

        # Pipe the $statsTimesList to awk as a sorted list to get the median.
        local median=$(echo "$statsTimesList" | tr " " "\n" | sort -n |
                       awk "$awkMedianOdd" midRow="$middleItem")
    fi

    # If an even number of items, the median is the mean average of the 2 middle items in the
    # ordered list.
    if [ "$medianItemsEvenOrOdd" = "EVEN" ]; then

        # Work out which are the 2 middle items.
        local middleItem1=""
        local middleItem2=""
        let "middleItem1 = statsTotalValidIp / 2"
        let "middleItem2 = middleItem1 + 1"

        # Awk expression to get the values of the 2 middle rows and then to work out and print
        # the median by calculating the mean average of the 2 middle rows.
        local awkMedianEven='{ if (NR == midRow1) med1 = $1; if (NR == midRow2) med2 = $1; } \
                             END { median = (med1 + med2) / 2; printf("%.3f", median) }'

        # Pipe the $statsTimesList to awk as a sorted list to get the median.
        local median=$(echo "$statsTimesList" | tr " " "\n" | sort -n |
                       awk "$awkMedianEven" midRow1="$middleItem1" midRow2="$middleItem2")
    fi

    # Echo $median for capture at point of function invocation.
    echo "$median"
}


# Display the statistics variables (used in check mode).
Display_Stats()
{
    # Trim whitespace from $statsTimesList and $statsValidIpAddressList.
    local sedExpTrim='s/^[ \t]*//g;s/[ \t]*$//g'
    statsTimesList=$(echo "$statsTimesList" | sed "$sedExpTrim")
    statsValidIpAddressList=$(echo "$statsValidIpAddressList" | sed "$sedExpTrim")

    # Find the fastest time of the successful retrieval times (3 decimal places).
    local timeFastest=$(Find_Fastest_Time)

    # Find the slowest time of the successful retrieval times (3 decimal places).
    local timeSlowest=$(Find_Slowest_Time)

    # Calculate the mean average of the successful retrieval times (3 decimal places).
    local timeMean=$(Calculate_Mean_Average_Time)

    # Calculate the median average of the successful retrieval times (3 decimal places).
    local timeMedian=$(Calculate_Median_Average_Time)

    # Calculate the percentages of successful and failed retrieval (2 decimal places).
    local bcExpPercentSuccess="($statsTotalValidIp / $urlArrayLength) * 100"
    local percentSuccess=$(printf "%.2f" $(echo "$bcExpPercentSuccess" | bc -l))
    local bcExpPercentFailed="100 - $percentSuccess"
    local percentFailed=$(printf "%.2f" $(echo "$bcExpPercentFailed" | bc -l))

    # Calculate the number of unique IP addresses held in $statsValidIpAddressList.
    local numUniqueIp=$(echo "$statsValidIpAddressList" | tr " " "\n" | sort -n | uniq | wc -l)

    # Output the statistics.

    echo "-----------------------------------------------------------------------------"

    printf "%-62s %s\n" "Total Number Sites Checked" "$urlArrayLength"

    printf "%-62s %-3s (%s%%)\n" "IP Addresses - Successfully Retrieved" \
                                 "$statsTotalValidIp" "$percentSuccess"

    printf "%-62s %-3s (%s%%)\n" "IP Addresses - Failed (Timed Out / Invalid IP)" \
                                 "$statsTotalInValidIp" "$percentFailed"

    printf "%-62s %s\n" "Timeout For Each Url (sec)" "$timeout"

    printf "%-62s %s\n" "Fastest IP Successful Retrieval (sec)" "$timeFastest"

    printf "%-62s %s\n" "Slowest IP Successful Retrieval (sec)" "$timeSlowest"

    printf "%-62s %s\n" "Mean Average IP Successful Retrieval (sec)" "$timeMean"

    printf "%-62s %s\n" "Median Average IP Successful Retrieval (sec)" "$timeMedian"

    # Issue a warning if not exactly 1 unique IP.
    if [ "$numUniqueIp" = "1" ]; then
        printf "%-62s %s\n" "Unique IP Addresses Retrieved (Should Be 1)" "$numUniqueIp"
    else
        printf "%-62s %s *WARNING*\n" "Unique IP Addresses Retrieved (Should Be 1)" "$numUniqueIp"
    fi

    # Echo a warning if the number of unique IP addresses is > 1, and list them.
    if [ "$numUniqueIp" -gt "1" ]; then
        echo ""
        echo "WARNING: The number of unique IP addresses retrieved exceeds one. It should be"
        echo "exactly one - your IP address - returned by all the sources used for IP address"
        echo "retrieval. One or more of the sources is no longer returning IP addresses"
        echo "correctly. You should download the most recent version of the getip script."
        echo "Advanced users can edit the urls in the script's sourceUrls array to remove"
        echo "urls which are no longer functioning. If the latest version of the script has"
        echo "a non-functioning source url in it, please contact the developer."
        echo ""

        # List each unique IP address in a table along with its number of occurrences.

        # This awk code uses a useful aspect of awk where any number or string in awk may be used
        # as an array index. In this case the IP addresses piped to awk will serve as the array
        # indexes for the countIP[] array. Also in awk if you perform an arithmetic operation to
        # a variable which has not yet been assigned a value then the variable is automatically
        # assigned a value of 0 before the arithmetic operation takes place. So in the code below
        # all the members of the countIP[] array are effectively initialized to 0.
        local awkExpIpCount='{ countIP[$1]++ } END { for (ip in countIP) \
                               printf("%-15d  -  %s\n", countIP[ip], ip); }'

        printf "Unique IP Addresses List:\n\n"
        printf "Num Occurrences  -  IP Address\n"
        echo "$statsValidIpAddressList" | tr " " "\n" | awk "$awkExpIpCount" | sort -n
    fi

    echo "-----------------------------------------------------------------------------"
}


# Flag variable to hold whether to calculate the time taken to get the IP address,
# this will only be done in either check mode or if verbose is set.
if [ "$operationMode" = "CHECK" -o "$verbose" = "TRUE" ]; then
    timeIpRetrieval="TRUE"
else
    timeIpRetrieval="FALSE"
fi

# Call the function which randomizes the $urlArray array.
if [ "$operationMode" = "GETIP" ]; then

    Randomize_Url_List

    # If verbose is set, echo various diagnostic information.
    if [ "$verbose" = "TRUE" ]; then
        printf "%-25s %s\n" "Source Urls Randomizing:" "Finished"
    fi
fi

# If in test url mode test the url, providing helpful output, and then exit.
if [ "$operationMode" = "TESTURL" ]; then

    # 'Pretty print' the test results.
    printf "%-21s%s\n" "Testing Url:" "$testUrlAddress"

    # Create a temp file for Get_Ip_From_Url() to use.
    tempFileNameForGetIp=$(mktemp -q -t "getip.tmp.XXXXXX")
    mktempFileCreationRetVal=$?

    if [ "$mktempFileCreationRetVal" -ne "0" ]; then
        Output_Error_Message "TempFileCreationFailed"
        exit "$ExitStatusErrorTempFileCreationFailed"
    fi

    # Use the function Get_Ip_From_Url() to retrieve the source $url, store its contents in the
    # $tempFileNameForGetIp temp file, and extract IP addresses from it. If one or more properly
    # formed IP addresses are retrieved then they will be placed in $ipAddress.

    # Time the IP address retrieval.
    timeStart=$(date +%s.%N)

    ipAddress=$(Get_Ip_From_Url "$testUrlAddress" "$tempFileNameForGetIp")
    getIpFromUrlRetVal=$?

    timeStop=$(date +%s.%N)
    timeTaken=$(printf "%.3F" $(echo "$timeStop - $timeStart" | bc -l))

    # Delete the temp file.
    if [ -f "$tempFileNameForGetIp" ]; then rm "$tempFileNameForGetIp"; fi

    # Handle the various return possibilities.

    if [ "$getIpFromUrlRetVal" -eq "$GetIpSingleValidIP" ]; then
        printf "%-21s%s\n" "Status:" "Success"
        printf "%-21s%s\n" "Outcome:" "Url returned a single valid IP address"
        printf "%-21s%s\n" "IP Address:" "$ipAddress"

    elif [ "$getIpFromUrlRetVal" -eq "$GetIpMultipleValidIP" ]; then
        printf "%-21s%s\n" "Status:" "Failure"
        printf "%-21s%s\n" "Outcome:" "Url returned more than one valid IP address"
        ipAddressCSV=$(echo "$ipAddress" | tr '\n' ' ')
        printf "%-21s%s\n" "IP Addresses:" "$ipAddressCSV"

    elif [ "$getIpFromUrlRetVal" -eq "$GetIpNoValidIP" ]; then
        printf "%-21s%s\n" "Status:" "Failure"
        printf "%-21s%s\n" "Outcome:" "Url did not return a valid IP address"

    elif [ "$getIpFromUrlRetVal" -eq "$GetIpTimedOut" ]; then
        printf "%-21s%s\n" "Status:" "Failure"
        printf "%-21s%s\n" "Outcome:" "Server timed out"
    fi

    # Output the time taken and the current timeout value.
    printf "%-21s%s\n" "Duration (Seconds):" "$timeTaken"
    printf "%-21s%s\n" "Timeout  (Seconds):" "$timeout"

    # The exit point of the script in test url mode.
    exit "$ExitStatusSuccess"
fi

# Array to hold the IP addresses retrieved in GETIP mode.
ipList=""

# Counter to hold how many IP addresses have so far been retrieved in GETIP mode.
ipCounter="0"

# Test error handling with 'fake' IP address.
# 1 = 1.2.3.4 IP address, 2 = has 2 IP addresses, 3 = no IP addresses.
# urlArray[1]="https://crius.feralhosting.com/gencon/fakeip1.html"
# urlArray[1]="https://crius.feralhosting.com/gencon/fakeip2.html"
# urlArray[1]="https://crius.feralhosting.com/gencon/fakeip3.html"

# The script's main loop iterates through the urls in the $urlArray array. If in GETIP mode
# the script will exit from within this loop if the IP address is successfully retrieved and
# then verified. If in check mode the loop will iterate through to completion.

for url in "${urlArray[@]}"; do

    # If in check mode or verbose is set then time the IP address retrieval.
    if [ "$timeIpRetrieval" = "TRUE" ]; then timeStart=$(date +%s.%N); fi

    # If verbose is set and in GETIP mode.
    if [ "$verbose" = "TRUE" -a "$operationMode" = "GETIP" ]; then
        printf "\n%-25s %s\n" "Trying Source:" "$url"
    fi

    # Create a temp file for Get_Ip_From_Url() to use.
    tempFileNameForGetIp=$(mktemp -q -t "getip.tmp.XXXXXX")
    mktempFileCreationRetVal=$?

    if [ "$mktempFileCreationRetVal" -ne "0" ]; then
        Output_Error_Message "TempFileCreationFailed"
        exit "$ExitStatusErrorTempFileCreationFailed"
    fi

    # Use the function Get_Ip_From_Url() to retrieve the source $url, store its contents in the
    # $tempFileNameForGetIp temp file, and extract IP addresses from it. If a single properly
    # formed IP address gets retrieved then it will be placed in $ipAddress.

    ipAddress=$(Get_Ip_From_Url "$url" "$tempFileNameForGetIp")
    getIpFromUrlRetVal=$?

    # Delete the temp file.
    if [ -f "$tempFileNameForGetIp" ]; then rm "$tempFileNameForGetIp"; fi

    # Set $ipStatus and $ipStatusVerbose on the basis of the Get_Ip_From_Url() function's
    # return value. The possible return values are as follows:

    # $GetIpSingleValidIP      - success, a single valid IP address was retrieved.
    # $GetIpNoValidIP          - failure, no valid IP address at all.
    # $GetIpMultipleValidIP    - failure, more than one valid IP address.
    # $GetIpTimedOut           - failure, the timeout was exceeded.

    if [ "$getIpFromUrlRetVal" -eq "$GetIpSingleValidIP" ]; then
        ipStatus="VALID_IP"
        ipStatusVerbose="Valid IP address: $ipAddress"

    elif [ "$getIpFromUrlRetVal" -eq "$GetIpNoValidIP" ]; then
        ipStatus="NO_IP_ADDRESS"
        ipStatusVerbose="Failed: No IP address"

    elif [ "$getIpFromUrlRetVal" -eq "$GetIpMultipleValidIP" ]; then
        ipStatus="IP_NOT_UNIQUE"
        ipStatusVerbose="Failed: More than one IP address"

    elif [ "$getIpFromUrlRetVal" -eq "$GetIpTimedOut" ]; then
        ipStatus="URL_TIMED_OUT"
        ipStatusVerbose="Failed: Server timed out"
    fi

    # If in check mode or verbose is set, calculate the time taken (reduce to 3 decimal places).
    if [ "$timeIpRetrieval" = "TRUE" ]; then
        timeStop=$(date +%s.%N)
        timeTaken=$(printf "%.3F" $(echo "$timeStop - $timeStart" | bc -l))
    fi

    # If verbose is set and in GETIP mode.
    if [ "$verbose" = "TRUE" -a "$operationMode" = "GETIP" ]; then
        printf "%-25s %s\n" "Status:" "$ipStatusVerbose"
        printf "%-25s %s\n" "Duration (Seconds):" "$timeTaken"
    fi

    # Code to handle the operation mode: GETIP

    # If operating in GETIP mode store valid IP addresses in an array and use Verify_IP_List() to
    # check that all the IPs in the array are the same. If they are all the same and the required
    # number of IP addresses to use for verification have been retrieved, then the IP address can
    # be echoed and the script can exit. If the IP addresses in the array are not all the same
    # then reset the variables and keep going so that different sources are then used.

    if [ "$operationMode" = "GETIP" -a "$ipStatus" = "VALID_IP" ]; then

        # Add the IP address to the verify array, and add 1 to the counter.
        ipList[$ipCounter]="$ipAddress"
        let "ipCounter = ipCounter + 1"

        # If verbose is set...
        if [ "$verbose" = "TRUE" ]; then
            printf "%-25s %s\n" "Add IP To List:" "$ipCounter of $numIpToUseForGetIP"
        fi

        # Check if all the IP addresses in the array are the same.
        Verify_IP_List "${ipList[@]}"
        multiIpCheckRetVal=$?

        # If the IP addresses in the array are not all the same then reset the variables.
        if [ "$multiIpCheckRetVal" -ne "0" ]; then

            if [ "$verbose" = "TRUE" ]; then
                printf "\n%-25s %s\n" "IP List Verification:" "Failed [IP addresses differed]"
                printf "%-25s %s\n" "Status:" "Restart using different sources"
            fi

            # Reset the array and counter variables.
            unset ipList
            ipCounter="0"
        fi

        # The array contains the required number of IP addresses to use for verification.
        # Note: The if statement below will only evaluate to true if the IP addresses in the array
        # are all the same, if they weren't then $ipCounter would have been set to 0 above.
        if [ "$ipCounter" -eq "$numIpToUseForGetIP" ]; then

            # If verbose is set...
            if [ "$verbose" = "TRUE" ]; then
                printf "\n%-25s %s" "IP List Verification:" "Succeeded "
                printf "%s\n" "[$ipCounter identical IP addresses]"
                printf "\n%-25s %s\n" "IPv4 address:" "$ipAddress"
            else
                if [ "$bareOutput" = "TRUE" ]; then
                    printf "%s\n" "$ipAddress"
                else
                    printf "%s\n" "IPv4 address: $ipAddress"
                fi
            fi

            exit "$ExitStatusSuccess"
        fi
    fi

    # Code to handle the operation mode: CHECK

    # If operating in check mode neatly display the source url, the IP address or an error
    # message if retrieving it failed, and the time taken to retrieve the IP address, for
    # each of the source urls and format the data as a table.

    if [ "$operationMode" = "CHECK" ]; then

        # awk expression for 'pretty printing' the test results.
        awkExprPrettyPrint='{ printf "%-8s %-53s %s\n", $1, $2, $3 }'

        # If the length of $url will muck up 'pretty printing', truncate it.
        urlLength=${#url}
        if [ "$urlLength" -gt "52" ]; then
            truncateUrl=${url:0:48}
            url="$truncateUrl..."
        fi

        # Pretty print the information in neat columns: time, url, IP Address / Error.
        if [ "$ipStatus" = "VALID_IP" ]; then
            echo "$timeTaken" "$url" "$ipAddress" | awk "$awkExprPrettyPrint"
        else
            echo "$timeTaken" "$url" "$ipStatus" | awk "$awkExprPrettyPrint"
        fi

        # Add info. to the stored statistics for displaying at the end.
        Add_To_Stats "$ipAddress" "$ipStatus" "$timeTaken"
    fi

done  # End of loop through $urlArray loop.


# If operating in GETIP mode, then if this section of the script is reached then the script failed
# to supply a valid IP address.
if [ "$operationMode" = "GETIP" ]; then
    Output_Error_Message "FailedToGetIPAddress"
    exit "$ExitStatusErrorFailedToGetIPAddress"
fi

# If operating in check mode, then display the check mode statistics.

if [ "$operationMode" = "CHECK" ]; then

    # Write an error message if all the urls failed.
    if [ "$statsTotalInValidIp" -eq "$urlArrayLength" ]; then
        Output_Error_Message "FailedToGetIPAddress"
        exit "$ExitStatusErrorCheckModeAllUrlsFailed"
    fi

    # Display the stats info.
    Display_Stats
fi

# The exit point of the script in check mode.
exit "$ExitStatusSuccess"

##
## END OF SCRIPT.
##
