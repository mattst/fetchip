#!/bin/bash

#
# Name:             getip
# Description:      Script to retrieve an external IPv4 address from IP providing web sites.
# Requirements:     UNIX / Linux / Bash / Requires either curl or wget to be installed.
# Usage:            getip [-m | -f | -c | -u url] [-n num_sources] [-t timeout_secs] [-v] [-h]
# Exit Status:      0 on success, and non-zero on failure.
# Author:           mattst@i-dig.info
# Version:
# Last Edited:      2015-09-29
# Homepage:         https://github.com/mattst/getip
# License:          GNU General Public License v3 - http://www.gnu.org/copyleft/gpl.html
#
#
# The complete list of all utilities and Bash shell commands used by the getip script:
#
# awk, bc, curl, date, disown, echo, exit, getopts, grep, hash, kill, man, mktemp, printf, ps,
# $RANDOM, rm, sed, sort, tr, uniq, unset, wc, wget. [wget or curl required, not both.]
#
# With the exception of wget and curl all of the above utilities and commands are expected to exist
# on all modern UNIX like operating systems. If neither wget nor curl are installed the script will
# advise the user to install one of them.
#
#
# Description:
#
# getip is a script used to retrieve an external IPv4 address from behind a router using web sites
# which provide the IP address in plain text or HTML. Note: IPv4 only, not IPv6.
#
# getip echoes the IP address so that it is displayed in the shell or so that it can be stored in a
# variable if getip is called from within another script.
#
# Command line options (all optional):
#
# -m           MULTI; get the IP from multiple sources and check they are all the same (default).
# -f           FAST; get the IP from just one source in order to echo it more quickly than multi.
# -c           CHECK; display the IP address returned by all the web sources and show stats.
# -u url       TEST; test an url for possible inclusion in the source urls and show info.
# -n number    Set the NUMBER of sources to use for verification in multi mode. Range >=2 and <=5.
# -t seconds   Set the TIMEOUT for each source. Real numbers are permitted (e.g. '1.5', '0.75').
# -b           Bare output; display only the IP address and not the "IPv4 address:" prefix.
# -v           VERBOSE; output information while the script is running.
# -h, --help   HELP; output program usage and help.
#
# Multi mode is the default mode so -m is not needed on the command line. The default number of
# sources to use in multi mode is 2.
#
#
# The 4 operation modes: MULTI, FAST, CHECK, and TESTURL.
#
# In both multi and fast modes the list of web sources (the list of web sites which provide your IP
# address) is randomized before use so that no source is used more often than any other. Note: the
# time taken to shuffle the list is negligible.
#
# From time to time a web page used as a source will stop providing IP addresses, either temporarily
# or permanently, but an example IP address might remain on the page, or an IP-like software version
# number might be present on the page (embedded within the HTML) and which could be mistaken for a
# real IP address. In such circumstances an IP address fetching script could provide a user with an
# incorrect IP address. getip uses multi mode by default which fetches the IP address from more than
# one source (2 by default) and makes sure they are the same. Users are advised to use multi mode.
#
#
# MULTI (default mode)   - Command line switches: -m and/or -n number_of_sources
#                        - No switch necessary, MULTI mode is used by default.
#
# In multi mode getip will retrieve the IP address from more than one source and check that all
# sources have supplied the same IP address. The default number of sources to use is 2 but this can
# be set on the command line with -n num where the range of values is >=2 and <=5. Note that the
# default is considered to be sufficient due to the unlikelihood of 2 sources both providing the
# same incorrect IP address. [Using 3 would be over-cautious, 5 in a state of paranoia.]
#
#
# FAST                   - Command line switch: -f
#
# In fast mode getip will retrieve the IP address from just one source with no verification. It is
# generally faster, though not guaranteed to be. It is suggested that fast mode only be used when a
# user already knows their IP address and is seeking confirmation of it, for instance if checking
# whether a connection to a VPN has finished or succeeded. Fast mode should never be used when
# calling getip from within another script.
#
#
# CHECK                  - Command line switch: -c
#
# In check mode getip will display a table in the shell of all the web sources, the IP address which
# was retrieved from the source, or a message of failure, and the time taken to retrieve the IP
# address. In addition it displays some statistics at the end. It can be used by users to check that
# all the sources are functioning correctly. getip will continue to function perfectly adequately
# with even 25% of the sources down. If more than 15% are down you may wish to download the latest
# version of the script or manually delete sources which aren't working from the list below.
#
#
# TESTURL                - Command line switch: -u url
#
# In test url mode getip will test the url to see if it is suitable for adding to the source list.
# getip will display a small table showing the url's status; whether the Url successfully returned a
# single valid IP address, or failed by supplying more than one valid IP address, no IP address at
# all, or if the timeout was exceeded. Only experienced users should use this feature to add an url
# to the source list. If you do use this to find a new url that is suitable for inclusion please
# contact the developer with the url.
#
#
# The other command line options:
#
# NUMBER OF SOURCES      - Command line switch: -n num_sources [Default 2, range: >=2 and <=5.]
#
# Sets the number of sources to use in the multi operation mode.
#
#
# TIMEOUT, FOR EACH SOURCE   - Command line switch: -t seconds
#                            - Range >=0.2 and <=30. [Real numbers are permitted.]
#                            - Default timeout in multi mode:    1.0
#                            - Default timeout in fast mode:     0.75
#                            - Default timeout in check mode:    10.0
#                            - Default timeout in test url mode: 10.0
#
# Sets the timeout in seconds for each source, not an overall timeout for the script. When a source
# gives no response or is slow to respond, getip simply moves on to the next source in the sources
# list. Each of the operation modes has its own default timeout (shown above). The allowed range is
# large, >=0.2 and <=30, as large variations in speed of web access and the user's physical location
# both mean a flexible timeout is sensible, however values less than 0.75 or greater than 3 are not
# usually advisable in multi or fast mode. In check and test url modes a high timeout facilitates
# checking whether sources are functioning at all or not.
#
# There is no 'global' timeout feature for getip, however the timeout multiplied by the number of
# sources means there is a de facto 'global' timeout.
#
#
# BARE                   - Command line switch: -b
#
# Turn bare output on - the script will display only the IP address and not the "IPv4 address:"
# prefix.
#
#
# VERBOSE                - Command line switch: -v
#
# Turns verbose on - the script will output diagnostic information while it runs.
#
#
# HELP                   - Command line switch: -h or --help
#
# Outputs program usage and help then exits.
#
#



##
## START OF SCRIPT.
##

# Set version number.
version="0.9b"

# The following list of web page urls all provide the IP address of the connecting machine. They
# each return an IP address either on its own or within some plain text or HTML. Some 'show your
# IP address' web pages have an example IP address on the page - such web pages should not be
# added. Note that pages which contain more than 1 unique IP address would be ignored by getip,
# they would not cause the script to supply the wrong IP address.

# Note #1: Be careful when editing of trailing '/'s at the end of urls. In very few cases it is
# essential that they are there or that they are not there, so paste accurately.

# Note #2: Single quotes in urls should be replaced with %27.
# e.g. http://www.dnswatch.info/what's-my-ip == http://www.dnswatch.info/what%27s-my-ip

sourceUrls=(
"http://aboutmyip.com/AboutMyXApp/AboutMyIP.jsp"
"http://aruljohn.com/"
"http://checkip.dyndns.com/"
"http://checkip.dyndns.org"
"http://cmyip.com/"
"http://crymyip.com/"
"http://en.dnstools.ch/show-my-ip.html"
"http://en.utrace.de"
"http://fmbip.com/"
"http://geomaplookup.net/"
"http://get.youripfast.com/?hl=en"
"http://gmyip.com/"
"http://groanmyip.com/"
"http://i-dig.info/ip/showip.php"
"http://icanhazip.com"
"http://ifconfig.co/"
"http://ip4.me/"
"http://ip.appspot.com"
"http://ip-check.info/?lang=en"
"http://ipchicken.com"
"http://ip.fruktsallad.net"
"http://ipinfodb.com/my_ip_location.php"
"http://ipinfo.info/html/my_ip_address.php"
"http://iplookup.flashfxp.com"
"http://ip-lookup.net/"
"http://mxtoolbox.com/WhatIsMyIP/"
"http://my-ip-address.com"
"http://myip.dnsomatic.com"
"http://myip.nmonitoring.com/"
"http://myip.ru/"
"http://network-tools.com"
"http://networktools.nl"
"http://passwordsgenerator.net/WhatIsMyIP/"
"http://remote.12dt.com"
"https://api.ipify.org?format=json"
"https://encodable.com/ip_address/"
"http://showip.net"
"https://ipleak.net/"
"http://smart-ip.net/"
"http://submit.apnic.net/templates/yourip.html"
"https://wtfismyip.com/"
"https://www.astrill.com/what-is-my-ip-address.php"
"https://www.dur.ac.uk/cis/network/findip/"
"https://www.google.com/search?q=Your+public+IP+address&gws_rd=cr"
"https://www.icuk.net/contact/ip.asp"
"https://www.milonic.com/myipaddress.php"
"https://www.name.com/ip"
"https://www.overplay.net/vpn/ip-address/what-is-my-ip-address.php"
"https://www.privateinternetaccess.com/pages/whats-my-ip/"
"https://www.ultratools.com/tools/yourIPResult"
"https://www.whatismybrowser.com/detect/what-is-my-ip-address"
"https://www.whatsmydns.net/whats-my-ip-address.html"
"http://tnx.nl/ip"
"http://torvpn.com/myip.html"
"http://webtools.csx.cam.ac.uk/myip/results.html"
"http://whatismyipaddress.com/ip-lookup"
"http://whatismyip.org/"
"http://whatsmyuseragent.com/"
"http://www.123myip.co.uk"
"http://www.bobborst.com/tools/whatsmyip/"
"http://www.displaymyip.com"
"http://www.dnsstuff.com/"
"http://www.dnswatch.info/what%27s-my-ip"
"http://www.exadium.com/tools/myip/"
"http://www.formyip.com/ipcountry.php"
"http://www.geoip.co.uk/"
"http://www.geoiptool.com"
"http://www.getip.com"
"http://www.howtofindmyipaddress.com"
"http://www.infosniper.net/"
"http://www.ip2location.com/"
"http://www.ip-adress.com/"
"http://www.ip-adress.eu/"
"http://www.ipadr.xyz/"
"http://www.ip.cc/index.php"
"http://www.ipgoat.com"
"http://www.ipgp.net/"
"http://www.ipligence.com/whatsmyip"
"http://www.iplocation.net"
"http://www.ip-lookup.com"
"http://www.ipnow.org"
"http://www.ipnumber.eu/ip/"
"http://www.iprivacytools.com/my-ip-address/"
"http://www.iptrackeronline.com"
"http://www.lawrencegoetz.com/programs/ipinfo/"
"http://www.mediacollege.com/internet/utilities/show-ip.shtml"
"http://www.moanmyip.com/"
"http://www.mon-ip.com/en/my-ip/"
"http://www.myglobalip.com/"
"http://www.myipnumber.com/my-ip-address.asp"
"http://www.nirsoft.net/show_my_ip_address.php"
"http://www.shmyip.com"
"http://www.showipinfo.net"
"http://www.showmemyip.com"
"http://www.showmyip.com.ar"
"http://www.showmyip.co.uk"
"http://www.show-my-ip.de/ipadresse.html"
"http://www.showmyip.gr"
"http://www.spyber.com/ip-lookup.php"
"http://www.techweekeurope.co.uk/what-is-my-ip-address"
"http://www.thinkbroadband.com/ip.html"
"http://www.tracemyip.org"
"http://www.urgentclick.com/whats-my-ip-address.php"
"http://www.ventrilo.com/myip.php"
"http://www.vermiip.es/show-my-ip/"
"http://www.viewmyip.co.uk/"
"http://www.webyield.net/cgi-bin/ip.cgi"
"http://www.whatismyip.co.uk/"
"http://www.whatismypublicip.com/"
"http://www.whatsmyipaddress.net/"
"http://www.whereisip.net/"
"http://www.who.is"
"http://www.whoismyisp.org/"
"http://www.yougetsignal.com/what-is-my-ip-address/"
);


#
# New urls tested and working - add them:
#
# None at present, done to Google search of "my ip address" (not exact phrase) up to page 20.
#
# Removed but listed here for possible future reinclusion:
#
# "http://ifconfig.me/ip"               - usually (but not always) very slow 5-10+ secs.
# "http://www.whoismyisp.org/"          - usually (but not always) very slow 5-10+ secs.
#


# IMPORTANT:
#
# The Randomize_Url_List() function needs the url array to be INDEXED IN NUMERICAL SEQUENCE FROM 0
# or it will not randomize the array correctly! The following loop takes the urls in $sourceUrls
# and creates the $urlArray array which is indexed in numerical sequence from 0, and which will be
# used during the script to access the various source urls. Why do it like this? Why not just
# create a 0 indexed array of the urls in the first place? The answer is I did, but it made
# removing no-longer-functioning urls a pain, because the index number sequence had to be manually
# fixed. I reasoned that a mistake could easily be made. This method of using a loop to create the
# 0 indexed $urlArray from the easy to edit $sourceUrls list allows bad urls to be quickly removed
# and new urls added without any risk to the array integrity or any significant speed penalty.

# Create the 0 indexed $urlArray array from the urls in $sourceUrls.
urlIndex="0"
for sourceUrl in "${sourceUrls[@]}"; do
    urlArray[$urlIndex]="$sourceUrl"
    let 'urlIndex = urlIndex + 1'
done

# Holds the number of urls in $urlArray (0 indexed, final element is $urlArrayLength-1).
urlArrayLength="$urlIndex"

# $operationMode holds the operation mode, default 'MULTI'. Possible values: 'MULTI', 'FAST',
# 'CHECK', or 'TESTURL'. 'MULTI' is the default mode.
operationMode="MULTI"

# Sets the default number of sources to use in multi mode. Recommended: 2 (Not: < 2 or > 5).
numIpToUseForMulti="2"

# Set the default timeout in seconds for the retrieval of each source. A different default timeout
# can be set for each mode. Timeouts may be fractions of a second, e.g. 1.5, 0.75, .75

# Keep the timeout low, so that if a source is offline or slow to respond, the script can move
# on to the next source. Recommended: 0.75 to 3.0.
timeoutMultiMode="1"

# In fast mode keep the timeout even lower, so that a slow source can be quickly skipped.
# Recommended: 0.5 to 1.5.
timeoutFastMode="0.75"

# In check mode set the timeout much higher to give every source a good chance to succeed and to
# see how long each of the sources take. Recommended: 10.
timeoutCheckMode="10"

# In test url mode set the timeout to give the url a chance to succeed. Recommended: 10.
timeoutTestUrlMode="10"

# Web url of source to test in test url mode.
testUrlAddress=""

# Flag variable to hold if the user has set the num source IPs to use for multi (the -n option).
userSetNumIpToUseForMulti="FALSE"

# Flag variable to hold if the user has set a timeout (the -t option).
userSetTimeout="FALSE"

# Flag variable to hold if the user has set the bare output option.
bareOutput="FALSE"

# Flag variable to hold if the user has turned on verbose reporting (the -v option).
verbose="FALSE"

# Counter to count how many modes the user set on the command line. Since only 1 mode can be set
# this facilitates checking the user has not inadvertently set more than 1 mode.
userSetModesCounter="0"

# Constants to hold the various exit statuses of the script.
ExitStatusSuccess="0"
ExitStatusErrorUrlArgInvalid="1"
ExitStatusErrorNumSourcesArgInvalid="2"
ExitStatusErrorTimeoutArgInvalid="3"
ExitStatusErrorOptionInvalid="4"
ExitStatusErrorArgMissing="5"
ExitStatusErrorUserSetMoreThanOneMode="6"
ExitStatusErrorUserSetNumIpToUseForMultiAndInvalidMode="7"
ExitStatusErrorOperationModeInvalid="8"
ExitStatusErrorWgetAndCurlNotInstalled="9"
ExitStatusErrorTempFileCreationFailed="10"
ExitStatusErrorMultiOrFastModeGettingIpFailed="11"
ExitStatusErrorCheckModeAllUrlsFailed="12"

# Constants to hold the various values returned by the Get_Ip_From_Url() function.
GetIpSingleValidIP="0"
GetIpNoValidIP="1"
GetIpMultipleValidIP="2"
GetIpTimedOut="3"


# Display help by redirecting the text of the man page to 'man'.
Display_Usage_Message()
{

man /dev/stdin <<EOF

.TH GETIP 1 "29 Sep 2015" "1.0" "GETIP VERSION 1.0"

.SH NAME

getip \- retrieves the WAN IP address

.SH SYNOPSIS

getip [-m | -f | -c | -u url] [-n num_sources] [-t timeout_secs] [-v] [-h]

.SH REQUIREMENTS

The BASH shell and either wget or curl must be installed. Most modern UNIX like systems come with BASH and wget pre-installed. wget and curl are both programs which download pages from the web. getip works equally well with them both. wget is used by default if both are installed on the system.

.SH DESCRIPTION

getip is a BASH script used to retrieve the WAN IP address from behind a router using web sites (sources) which provide the IP address in plain text or HTML.

From time to time a web page used as a source will stop providing IP addresses, either temporarily or permanently, but an example IP address might remain on the page, or an IP-like software version number might be present, embedded in the HTML, and which could be mistaken for a real IP address (although the script tries hard to spot version numbers so they can be ignored). In such cases an IP address fetching script could provide a user with an incorrect IP address. getip uses multi mode by default to prevent this from happening.

In multi mode the IP address is retrieved from multiple sources (default: 2) and compared, so that the correct IP address can be provided. Users are advised to use multi mode in preference to fast mode.

The getip script retrieves IPv4 addresses only and not IPv6 addresses.

This script currently contains over 100 web sources.

The list of web sources is randomized every time the script is run. This is so that undue pressure is not placed on servers near the top of the list. The randomizing process is done very quickly and does not have a significant impact on the running time of the script.

.SH OPTIONS
.BR
In typical usage no options are necessary.
.BR

.TP
\fB\-m\fR
Multi mode (default); fetch the IP address from multiple sources and check that they are all the same. In multi mode the default number of sources to use is 2. This is the default mode so \fB\-m\fR is optional. See: \fB\-n\fR \fBnum_sources\fR

.TP
\fB\-f\fR
Fast mode; fetch the IP address from just one source in order to retrieve it more quickly than in multi mode. Fast mode is not guaranteed to be faster than multi mode but on average it will be slightly faster. It is advisable that users only use fast mode to confirm their IP address when it is already known, e.g. checking a VPN connection. In some circumstances an incorrect IP address can be returned in fast mode, see \fBDescription\fR section above.

.TP
\fB\-c\fR
Check mode; displays a table containing the url of each source, the IP address that it returned (or a failure message), the time taken to retrieve the IP address, and various statistics. Used to test the sources list.

.TP
\fB\-u\fR \fBurl\fR
Test Url mode; tests an url for inclusion in the sources list. It will display whether the url returned a single IP address (which is required for inclusion in the sources list), multiple IP addresses, or no IP addresses at all. To aid debugging it will list all IP addresses returned.

.TP
\fB\-n\fR \fBnum_sources\fR
Sets the Number of sources to use in multi mode. The allowed range of values is >=2 and <=5. The default value is 2.

.TP
\fB\-t\fR \fBnum_seconds\fR
Sets the Timeout for each source. This is not an overall timeout for the script. When a source gives no response or is slow to respond, getip moves on to the next source and this is the timeout in seconds for each one. Note: Real numbers are permitted, e.g. 0.75, 1.5, .85, etc. The allowed range of values is >=0.2 and <=30 (but these extremes are overkill).

The default timeouts are dependant on mode, in seconds they are; multi mode 1, fast mode 0.75, check mode 10, test url mode 10.

.TP
\fB\-b\fR
Bare output; display only the IP address and not the "IPv4 address:" prefix.

.TP
\fB\-v\fR
Verbose; display detailed information while the script runs.

.TP
\fB\-h\fR, \fB\-\-help\fR
Help; display usage and help.

.TP
\fB\-\-version\fR
Display version number.

.SH EXIT STATUS
getip returns 0 on success, and non-zero on failure.

.SH BUGS
No known bugs.

.SH HOMEPAGE
https://github.com/mattst/getip
.LP
Feel free to submit new IP address providing web pages to be added to the sources list.

.SH AUTHOR
<mattst@i-dig.info>
EOF
}


# Function which sends the various error messages to STDERR.
Output_Error_Message()
{
    # Assign $errToDisplay the value of the 1st function arg (NOT script arg).
    local errToDisplay=$1

    # Assign $additionalInfo the value of the 2nd function arg (NOT script arg).
    # Some errors will need some extra information to be displayed.
    local additionalInfo=$2

    # The standard error message for all errors.

    echo "getip v. $version" >&2
    echo "" >&2
    echo "An error has occurred, use \"getip -h\" for usage and help." >&2
    echo "" >&2

    # The error messages:

    # The arg given to the -u option is invalid.
    if [ "$errToDisplay" = "UrlArgInvalid" ]; then
        echo "The argument given to the -u option is invalid." >&2
        echo "" >&2
        echo "The \"-u\" option must be followed by the web url to test." >&2
        echo "The url must begin with the letters 'http'." >&2
        echo "" >&2
        echo "e.g. getip -u \"http://www.web.org/url/to/check/ip.html\"" >&2
    fi

    # The arg given to the -n option is invalid.
    if [ "$errToDisplay" = "NumSourcesArgInvalid" ]; then
        echo "The argument given to the -n option is invalid: $additionalInfo" >&2
        echo "" >&2
        echo "The \"-n\" option sets the number of sources to use for verification in" >&2
        echo "multi mode and it requires a positive number in the range >= 2 and <= 5." >&2
        echo "The default number of sources to use for verification is 2." >&2
        echo "" >&2
        echo "e.g. \"getip -n 2\", \"getip -n 3\", etc." >&2
    fi

    # The arg given to the -t option is invalid.
    if [ "$errToDisplay" = "TimeoutArgInvalid" ]; then
        echo "The argument given to the -t option is invalid: $additionalInfo" >&2
        echo "" >&2
        echo "The \"-t\" option sets the timeout value in seconds for each source." >&2
        echo "It requires the number of seconds (real numbers are permitted)." >&2
        echo "The valid range is between >=0.2 and <=30 although for multi and" >&2
        echo "fast modes a value between >=0.75 and <=3 is suggested." >&2
        echo "See help for the default timeout values of the various modes." >&2
        echo "" >&2
        echo "e.g. \"getip -t 1\", \"getip -t 0.75\", \"getip -t 2.5\", etc." >&2
    fi

    # The option entered is invalid.
    if [ "$errToDisplay" = "OptionInvalid" ]; then
        echo "An invalid option has been entered:" >&2
        echo "" >&2
        echo "Usage: getip [-m | -f | -c] [-t timeout_secs] [-n num_sources] [-v] [-h]" >&2
    fi

    # The arg is missing for a option that requires an arg.
    if [ "$errToDisplay" = "ArgMissing" ]; then
        echo "The argument is missing for the option: -$additionalInfo" >&2
        echo "" >&2
        echo "Usage: getip [-m | -f | -c] [-t timeout_secs] [-n num_sources] [-v] [-h]" >&2
    fi

    # More than 1 mode has been set on the command line.
    if [ "$errToDisplay" = "UserSetMoreThanOneMode" ]; then
        echo "More than 1 operation mode has been entered. Only 1 mode can be used at a" >&2
        echo "time, one of: multi (-m), fast (-f), check (-c), or test url (-u url)." >&2
        echo "Multi is the default mode." >&2
        echo "" >&2
        echo "Usage: getip [-m | -f | -c] [-t timeout_secs] [-n num_sources] [-v] [-h]" >&2
    fi

    # The number of sources to use in multi mode has been set along with an invalid mode.
    if [ "$errToDisplay" = "UserSetNumIpToUseForMultiAndInvalidMode" ]; then
        echo "The number of sources to use for verification in multi mode has been set using" >&2
        echo "\"-n num\" but a different mode has also been set. \"-n num\" can only be used" >&2
        echo "with multi mode, it is incompatible with the other modes. Multi mode is the" >&2
        echo "default mode so \"-n num\" can be used alone or optionally with \"-m\"." >&2
        echo "" >&2
        echo "e.g. \"getip -n 3\", \"getip -m -n 4\", etc." >&2
    fi

    # Somehow (user editing) an invalid operation mode has been set.
    if [ "$errToDisplay" = "InvalidOperationMode" ]; then
        echo "Invalid operation mode: $additionalInfo" >&2
        echo "" >&2
        echo "Someone has edited the getip script and made an error when setting the" >&2
        echo "operation mode variable, it is not set to a valid operation mode." >&2
    fi

    # Neither wget nor curl are installed on the OS.
    if [ "$errToDisplay" = "WgetAndCurlNotInstalled" ]; then
        echo "The getip script requires either 'wget' or 'curl' to access the web, please" >&2
        echo "install one of them in order to use this script. Both wget and curl are" >&2
        echo "programs that can retrieve web pages, and they are widely available for all" >&2
        echo "UNIX/Linux based systems. The getip script works equally well with either." >&2
    fi

    # Creating the temp file failed.
    if [ "$errToDisplay" = "TempFileCreationFailed" ]; then
        echo "The getip script failed to create a required temporary file." >&2
        echo "" >&2
        echo "The script uses 'mktemp' to create temporary files. It is possible that mktemp" >&2
        echo "is not on your system although it is a standard component of UNIX/Linux based" >&2
        echo "systems. There may be a problem with the environment variable \$TMPDIR being" >&2
        echo "incorrectly set, or with creating files in the standard '/tmp/' directory." >&2
    fi

    # In check mode all the urls failed.
    if [ "$errToDisplay" = "CheckModeAllUrlsFailed" ]; then
        echo "In check mode - the getip script has failed to get an IP address from every" >&2
        echo "single one of the web sources (there are currently $urlArrayLength)." >&2
        echo "" >&2
        echo "The most likely reasons for this failure are that there is currently no web" >&2
        echo "access available to the computer, some part of the security system is denying" >&2
        echo "getip a web connection, or possibly the timeout value has been set very low." >&2
        echo "Diagnosing the problem further than that is beyond the scope of this error" >&2
        echo "message, in short: you are on your own." >&2
        echo "" >&2
        echo "P.S. If you have web access and this script is very old, you could download" >&2
        echo "the latest version of the script from the url above, otherwise YAOYO." >&2
    fi
}

# Test error messages:
#Output_Error_Message "UrlArgInvalid"
#Output_Error_Message "NumSourcesArgInvalid" "8"
#Output_Error_Message "TimeoutArgInvalid" "60"
#Output_Error_Message "OptionInvalid"
#Output_Error_Message "ArgMissing" "t"
#Output_Error_Message "UserSetMoreThanOneMode"
#Output_Error_Message "UserSetNumIpToUseForMultiAndInvalidMode"
#Output_Error_Message "InvalidOperationMode" "NONE"
#Output_Error_Message "WgetAndCurlNotInstalled"
#Output_Error_Message "TempFileCreationFailed"
#Output_Error_Message "CheckModeAllUrlsFailed"
#exit 0


# Before handling the arguments with getopts, check for long options:

# Check if the first arg is "--help", if so display help and exit (-h is handled by getopts).
if [ "$1" = "--help" -o "$1" = "-?" ]; then
    Display_Usage_Message
    exit "$ExitStatusSuccess"

# Check if the first arg is "--version", if so display version number and exit.
elif [ "$1" = "--version" ]; then
    echo "getip v. $version"
    exit "$ExitStatusSuccess"
fi


# Use getopts to handle the command line arguments. ToDo: Add long option support.
while getopts ":cfmu:bvhn:t:" option; do

    case $option in

        c)
            # -c has been used, set operation mode to check.
            operationMode="CHECK"
            let "userSetModesCounter = userSetModesCounter + 1"
            ;;

        f)
            # -f has been used, set operation mode to fast.
            operationMode="FAST"
            let "userSetModesCounter = userSetModesCounter + 1"
            ;;

        m)
            # -m has been used, set operation mode to multi.
            operationMode="MULTI"
            let "userSetModesCounter = userSetModesCounter + 1"
            ;;

        u)
            # -u url has been used, set operation mode to test url and set the url address.
            operationMode="TESTURL"
            testUrlAddress="$OPTARG"
            let "userSetModesCounter = userSetModesCounter + 1"

            # Check if $testUrlAddress is an url by seeing if the first 4 chars are 'http'.
            urlFirst4Chars=${testUrlAddress:0:4}
            urlFirst4CharsLowerCase=$(echo "$urlFirst4Chars" | tr '[:upper:]' '[:lower:]')

            if [ "$urlFirst4CharsLowerCase" != "http" ]; then
                Output_Error_Message "UrlArgInvalid"
                exit "$ExitStatusErrorUrlArgInvalid"
            fi
            ;;

        b)
            # -b has been used, turn on bare output.
            bareOutput="TRUE"
            ;;

        v)
            # -v has been used, turn on verbose.
            verbose="TRUE"
            ;;

        h)
            # -h has been used, display help and then exit.
            Display_Usage_Message
            exit "$ExitStatusSuccess"
            ;;

        n)
            # -n num has been used, set the num source IPs to use and flag variable.
            numIpToUseForMulti="$OPTARG"
            userSetNumIpToUseForMulti="TRUE"

            # Use sed to check that $numIpToUseForMulti is a single digit >=2 and <=5.
            numMultiMin="2"
            numMultiMax="5"

            sedExpIsNumInRange="s/^[$numMultiMin-$numMultiMax]\{1\}$/SINGLE_DIGIT_IN_RANGE/g"
            isNumInRange=$(echo "$numIpToUseForMulti" | sed "$sedExpIsNumInRange")

            # A single digit in range has not been entered.
            if [ "$isNumInRange" != "SINGLE_DIGIT_IN_RANGE" ]; then
                Output_Error_Message "NumSourcesArgInvalid" "$numIpToUseForMulti"
                exit "$ExitStatusErrorNumSourcesArgInvalid"
            fi
            ;;

        t)
            # -t seconds has been used, set the timeout flag and arg variables.
            timeoutSecondsArg="$OPTARG"
            userSetTimeout="TRUE"

            # Check that $timeoutSecondsArg is a number, int or real. This is a Bash hack to use
            # awk to check whether a variable is any kind of number (int or real).
            awkIsNum='END { if ($1 + 0 == $1) print "Num"; else print "NotNum" }'
            awkIsNumRetVal=$(echo "$timeoutSecondsArg" | awk "$awkIsNum")

            if [ "$awkIsNumRetVal" = "NotNum" ]; then
                Output_Error_Message "TimeoutArgInvalid" "$timeoutSecondsArg"
                exit "$ExitStatusErrorTimeoutArgInvalid"
            fi

            # Check that $timeoutSecondsArg is a positive number in range, >=0.2 and <=30.
            timeoutRangeMin="0.2"
            timeoutRangeMax="30"

            bcExpIsNumInRange="if ($timeoutSecondsArg < $timeoutRangeMin || \
                                   $timeoutSecondsArg > $timeoutRangeMax) 1 else 0"

            bcExpIsNumInRangeRetVal=$(echo "$bcExpIsNumInRange" | bc -l)

            # A positive number in range has not been entered.
            if [ "$bcExpIsNumInRangeRetVal" -eq "1" ]; then
                Output_Error_Message "TimeoutArgInvalid" "$timeoutSecondsArg"
                exit "$ExitStatusErrorTimeoutArgInvalid"
            fi
            ;;

        \?)
            # User entered an invalid option, e.g. '-x'. Note: Invalid args with no '-' prefix,
            # are handled immediately after this while loop.
            Output_Error_Message "OptionInvalid"
            exit "$ExitStatusErrorOptionInvalid"
            ;;

        :)
            # User omitted the required additional arg of either the, -u, -n or -t option.
            Output_Error_Message "ArgMissing" "$OPTARG"
            exit "$ExitStatusErrorArgMissing"
            ;;
    esac
done


# getopts stops processing args if it encounters an arg without a '-' prefix (unless it is an
# $OPTARG in which case processing continues). Check if any invalid args have been entered by
# working out how many args getopts has actually processed, shifting them off, and if more
# than 0 args remain then an invalid arg must have been entered.

let "numArgsProcessedByGetopts = OPTIND - 1"
shift "$numArgsProcessedByGetopts"
numArgsRemaining="$#"

if [ "$numArgsRemaining" -gt "0" ]; then
    Output_Error_Message "OptionInvalid"
    exit "$ExitStatusErrorOptionInvalid"
fi

# If the user set more than 1 mode on the command line, display error and exit.
if [ "$userSetModesCounter" -gt "1" ]; then
    Output_Error_Message "UserSetMoreThanOneMode"
    exit "$ExitStatusErrorUserSetMoreThanOneMode"
fi

# If the user set the number of sources to use in multi mode and also set the mode to fast,
# check, or test url mode, display error and exit.
if [ "$operationMode" != "MULTI" ]; then
    if [ "$userSetNumIpToUseForMulti" = "TRUE" ]; then
        Output_Error_Message "UserSetNumIpToUseForMultiAndInvalidMode"
        exit "$ExitStatusErrorUserSetNumIpToUseForMultiAndInvalidMode"
    fi
fi

# Set the appropriate $timeout and check that the operation mode is valid.

if [ "$operationMode" = "FAST" ]; then
    timeout="$timeoutFastMode"
elif [ "$operationMode" = "MULTI" ]; then
    timeout="$timeoutMultiMode"
elif [ "$operationMode" = "CHECK" ]; then
    timeout="$timeoutCheckMode"
elif [ "$operationMode" = "TESTURL" ]; then
    timeout="$timeoutTestUrlMode"
else
    Output_Error_Message "InvalidOperationMode" "$operationMode"
    exit "$ExitStatusErrorOperationModeInvalid"
fi

# If the user set the timeout on the command line then use that instead of the default.
if [ "$userSetTimeout" = "TRUE" ]; then
    timeout="$timeoutSecondsArg"
fi

# If the user has set both verbose and bare output ignore the latter, verbose trumps bare.
if [ "$verbose" = "TRUE" -a "$bareOutput" = "TRUE" ]; then
    bareOutput="FALSE"
fi

# Either wget or curl can be used to download the source urls.
# $urlDownloadProgram will hold which to use, either: 'WGET' or 'CURL'.

# Set the default download program (which to use if both are installed).
# urlDefaultDownloadProgram="CURL"
urlDefaultDownloadProgram="WGET"

# Check whether wget and curl are installed, at least one is required.
hash wget > /dev/null 2>&1
isWgetInstalled=$?
hash curl > /dev/null 2>&1
isCurlInstalled=$?

# Decide which of wget or curl to use for downloading.

# If both wget and curl are installed, use the default.
if [ "$isWgetInstalled" -eq "0" -a "$isCurlInstalled" -eq "0" ]; then
    urlDownloadProgram="$urlDefaultDownloadProgram"

# If only wget is installed, use that.
elif [ "$isWgetInstalled" -eq "0" -a "$isCurlInstalled" -ne "0" ]; then
    urlDownloadProgram="WGET"

# If only curl is installed, use that.
elif [ "$isCurlInstalled" -eq "0" -a "$isWgetInstalled" -ne "0" ]; then
    urlDownloadProgram="CURL"

# If neither wget nor curl are installed, display error and exit.
else
    Output_Error_Message "WgetAndCurlNotInstalled"
    exit "$ExitStatusErrorWgetAndCurlNotInstalled"
fi


# Function that randomizes the $urlArray array. Since this script is being publicly released it is
# sensible to randomize the sources so as not to place undue pressure on any one server. This is
# an implementation of the Knuth shuffle algorithm (aka Fisher-Yates shuffle), which is a very
# efficient randomizer, needing just one pass through an array, so time complexity is: O(n)
# The function takes ~40 ms on a low-level PC with 51 elements in the $urlArray array.
# More information on the Knuth shuffle, see here: http://en.wikipedia.org/wiki/Knuth_shuffle
# IMPORTANT: THE $urlArray ARRAY MUST BE INDEXED IN NUMERICAL SEQUENCE FROM 0 FOR THIS FUNCTION.
Randomize_Url_List()
{
    # Bash $RANDOM provides a random number in the range 0..32767 so 32768 possible values.
    local randMax="32768"

    # Start at the number of items in the array (i.e. final element's index + 1).
    local index=$urlArrayLength

    # Loop down through the array randomly swapping the current element with another randomly
    # chosen element (possibly itself). The use of >1 needs a moment to understand... if instead
    # it was > 0 then the final iteration would always swap index 0 with itself.
    while [ "$index" -gt "1" ]; do

        # Modulo bias avoidance as per Knuth shuffle algorithm description. Use bc to calculate the
        # highest usable random number so that the modulo by index calculation will not result in
        # any modulo bias. [scale=0 means integer arithmetic, the division will be rounded down.]

        local bcExpHighestAcceptableRandNum="scale=0; (($randMax / $index) * $index) - 1"
        local highestAcceptableRandNum=$(echo "$bcExpHighestAcceptableRandNum" | bc)

        # Get a random number within the modulo bias avoidance range.
        local randNum=$RANDOM
        while [ "$randNum" -gt "$highestAcceptableRandNum" ]; do
            randNum=$RANDOM
        done

        # Force the random number into the range 0..index-1.
        let "randIndex = randNum % index"

        # Decrement index to reference the current 'last' element in the array. For the first loop
        # iteration index will be $urlArrayLength - 1 (the final element of the array) and for the
        # last loop iteration index will be 1. By doing so the current index will be swapped with
        # a randomly chosen index ($randIndex) in the range 0..index, so elements will sometimes
        # be 'swapped' with themselves (if no elements could stay put it wouldn't be random).

        let "index = index - 1"
        local tempUrl=${urlArray[$index]}
        urlArray[$index]=${urlArray[$randIndex]}
        urlArray[$randIndex]=$tempUrl

    done
}


# Function to extract valid IP addresses from the file path given in the 1st function arg. As
# output it echos a list of valid IP addresses seperated by newlines for capture in a variable
# at the point of function invocation.
Extract_Ip_Addresses_From_File()
{
    # Assign $fileName the value of the 1st function arg (NOT script arg). The function will
    # extract valid IP addresses from the file $fileName which will be the temp file used to
    # store the contents downloaded from the web sources.
    local fileName="$1"

    # The following Awk program will search for and print all valid IP addresses in the file
    # which is given to it as input.

    # The regex ipLikeSequence deliberately matches IP address like sequences which are too long
    # to be a valid IP so that the regex does not examine something like '63.27.11.34.98' and
    # match just the '63.27.11.34' section of it, and in so doing cause something that is
    # definitely not an IP address to get mistaken for a valid one. IP address like sequences
    # are checked in the END section to make sure they have exactly 4 segments, separated by
    # dots (".") and that each of the 4 numbers are within the 0..255 range of a valid IP.

    # The regex digitSequenceTooLongNotIP will match sequences of numbers which are longer than
    # 3 digits. There are all removed as they can not possibly be part of an IP address.

    # The regex versioningNotIP attempts to spot version numbers which happen to be in the same
    # format as an IP address (which they are often are). e.g. Version 1.2.0.12
    # Any ipLikeSequence which follows words like "Version", "Ver", or "V", will be removed.

    # Version numbers are also often embedded in an url like "1.6.1.0" in these examples:
    # e.g. <script language="JavaScript" src="http://web.com/libs/1.6.1.0/file.js"></script>
    # e.g. <script language="JavaScript" src="http://web.com/libs/v.1.6.1.0/file.js"></script>
    # The regexes beginsWithFwdSlashNotIP and endsWithFwdSlashNotIP match an ipLikeSequence which
    # begins or ends with a forward slash so that those sequences can be removed.

    local awkExtractIPAddresses='
    BEGIN {
        # Regex to match an IP address like sequence (even if too long to be an IP). This is
        # deliberately a loose match, the END section will check for IP address validity.
        ipLikeSequence = "[0-9]+[.][0-9]+[.][0-9]+[.][0-9]+[0-9.]*";

        # Regex to match a number sequence longer than 3 digits.
        digitSequenceTooLongNotIP = "[0-9][0-9][0-9][0-9]+";

        # Regex to match an IP address like sequence which is a version number.
        # Equivalent to "(version|ver|v)[ .:]*" in conjunction with: line = tolower($0);
        versioningNotIP = "[Vv]([Ee][Rr]([Ss][Ii][Oo][Nn])?)?[ .:]*" ipLikeSequence;

        # Regexes to match IP address like sequences next to forward slashes, to avoid version
        # numbers in urls: e.g. http://web.com/libs/1.6.1.0/file.js
        beginsWithFwdSlashNotIP = "[/]" ipLikeSequence;
        endsWithFwdSlashNotIP = ipLikeSequence "[/]";
    }
    {
        # Set line to the current line (more efficient than using $0 below).
        line = $0;

        # Replace sequences on line which will interfere with extracting genuine IPs. Use a
        # replacement char and not the empty string to avoid accidentally creating a valid IP
        # address from digits on either side of the removed sections. Use "/" as the replacement
        # char for the 2 "FwdSlash" regexes so that multiple number dot slash sequences all get
        # removed, as using "x" could result in inadvertently leaving such a sequence in place.
        # e.g. "/lib1.6.1.0/1.2.3.4/5.6.7.8/file.js" would leave "/lib1.6.1.0xx/file.js".

        gsub(digitSequenceTooLongNotIP, "x", line);
        gsub(versioningNotIP, "x", line);
        gsub(beginsWithFwdSlashNotIP, "/", line);
        gsub(endsWithFwdSlashNotIP, "/", line);

        # Loop through the current line matching IP address like sequences and storing them in
        # the index of the array ipUniqueMatches. By using ipMatch as the array index duplicates
        # are avoided and the values can be easily retrieved by the for loop in the END section.
        # match() automatically sets the built in variables RSTART and RLENGTH.

        while (match(line, ipLikeSequence))
        {
            ipMatch = substr(line, RSTART, RLENGTH);
            ipUniqueMatches[ipMatch];
            line = substr(line, RSTART + RLENGTH + 1);
        }
    }
    END {
        # Define some IP address related constants.
        ipRangeMin = 0;
        ipRangeMax = 255;
        ipNumSegments = 4;
        ipDelimiter = ".";

        # Loop through the ipUniqueMatches array and print any valid IP addresses. The awk "for
        # each" type of loop is different from the norm. It provides the indexes of the array
        # and NOT the values of the array elements which is more usual in this type of loop.

        for (ipMatch in ipUniqueMatches)
        {
            numSegments = split(ipMatch, ipSegments, ipDelimiter);
            if (numSegments == ipNumSegments &&
                ipSegments[1] >= ipRangeMin && ipSegments[1] <= ipRangeMax &&
                ipSegments[2] >= ipRangeMin && ipSegments[2] <= ipRangeMax &&
                ipSegments[3] >= ipRangeMin && ipSegments[3] <= ipRangeMax &&
                ipSegments[4] >= ipRangeMin && ipSegments[4] <= ipRangeMax)
            {
                print ipMatch;
            }
        }
    }'

    # Extract valid IP addresses from $fileName, they will each be separated by a new line.
    local awkValidIpAddresses=$(awk "$awkExtractIPAddresses" < "$fileName")

    # Echo $awkValidIpAddresses for capture in a variable at the point of function invocation.
    echo "$awkValidIpAddresses"
}


# Function that retrieves the source's content and returns all unique IP addresses in it. The
# function provides an accurate timeout facility; neither curl nor wget reliably honour any
# timeout value which has been set nor do they allow timeouts in fractions of a second. Since
# getip uses many different sources a low timeout is used, if one source fails to return very
# quickly then the next source is tried. With this methodology a reliable and accurate low
# timeout is required, this function provides it.
Get_Ip_From_Url()
{
    # Assign $urlToDownload the value of the 1st function arg (NOT script arg).
    local urlToDownload="$1"

    # Assign $tempFileName the value of the 2nd function arg (NOT script arg). This will be used
    # to store the contents of the url.
    local tempFileName="$2"

    # Download the url and store its contents in the temp file. The process is forked to facilitate
    # the timeout procedure. The use of disown, which removes a job from the shell's active jobs
    # table, is so that if the process is later killed (which it will be if it times out) then
    # no shell message is displayed.

    # Some sources (very few) won't work without the user agent header being sent.
    # We are not trying to hide that this is a script, use a user agent header like googlebot's:
    # Googlebot 2.1: "Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)"
    local userAgent="Mozilla/5.0 (compatible; getipscript/$version; \
                                  +https://github.com/mattst/getip)"

    # Store the start time for the timeout. Note: %s seconds, %N nanoseconds.
    local timeoutStart=$(date +%s.%N)

    # Use wget to download the url.
    if [ "$urlDownloadProgram" = "WGET" ]; then

        wget --quiet --tries=1 --user-agent="$userAgent" --output-document=- \
             "$urlToDownload" > "$tempFileName" &

        urlDownloadProcessId=$!
    fi

    # Use curl to download the url.
    if [ "$urlDownloadProgram" = "CURL" ]; then

        curl --silent --user-agent "$userAgent" "$urlToDownload" > "$tempFileName" &

        urlDownloadProcessId=$!
    fi

    # For some reason even if kill has both stdout and stderr redirected to /dev/null the death of
    # the process is still output, using disown to remove the job from the shell's active jobs
    # table stops this from happening so there are no unsightly terminal messages.
    disown "$urlDownloadProcessId"

    # The following loop handles the timeout procedure for the url download process. ps is used to
    # see if the download process is still alive. The loop will finish when the process has
    # completed or when the timeout is exceeded.

    local isUrlDownloadDone="FALSE"
    local isUrlDownloadTimedOut="FALSE"

    while [ "$isUrlDownloadDone" = "FALSE" -a "$isUrlDownloadTimedOut" = "FALSE" ]; do

        # Store whether the url download process is still listed by ps.
        ps -e | grep --quiet "$urlDownloadProcessId"
        local processGrepRetVal=$?

        # If the url download process has finished.
        if [ "$processGrepRetVal" -ne "0" ]; then
            isUrlDownloadDone="TRUE"

        # If the url download process has not finished.
        else
            # Store the current time for the timeout. Note: %s seconds, %N nanoseconds.
            local timeoutNow=$(date +%s.%N)

            # Use bc to check if the timeout has been exceeded.
            local bcExpTimeout="if (($timeoutNow - $timeoutStart) > $timeout) 1 else 0"
            local bcExpTimeoutRetVal=$(echo "$bcExpTimeout" | bc -l)

            # The timeout has been exceeded.
            if [ "$bcExpTimeoutRetVal" -eq "1" ]; then
                isUrlDownloadTimedOut="TRUE"
            fi
        fi
    done

    # If the url download process completed sucessfully.
    if [ "$isUrlDownloadDone" = "TRUE" ]; then

        # Use the function Extract_Ip_Addresses_From_File() to extract valid IP addresses from
        # $tempFileName. Each IP address will be separated by a new line but if the source is
        # working as expected then there will be exactly one IP address.
        local ipAddressList=$(Extract_Ip_Addresses_From_File "$tempFileName")

        # Array to hold the IP address or addresses and an associated counter.
        local ipAddressValidArray=""
        local ipAddressValidCounter="0"

        # Iterate through $ipAddressList storing the IP address(es) in the array.
        for validIpAddress in $(echo "$ipAddressList" | tr "\n" " "); do
            ipAddressValidArray[$ipAddressValidCounter]="$validIpAddress"
            let "ipAddressValidCounter = ipAddressValidCounter + 1"
        done

        # If the length of the array is exactly 1 then that is considered to be the user's IP
        # address, it is echoed so that it can be placed in a variable at the point of function
        # invocation, and the constant $GetIpSingleValidIP is returned - success.
        if [ "$ipAddressValidCounter" -eq "1" ]; then
            echo "${ipAddressValidArray[0]}"
            return "$GetIpSingleValidIP"

        # If the array has no members then the constant $GetIpNoValidIP is returned, no valid
        # IP address was found - failure.
        elif [ "$ipAddressValidCounter" -lt "1" ]; then
            return "$GetIpNoValidIP"

        # If the length of the array is more than 1 then the constant $GetIpMultipleValidIP is
        # returned, more than one unique and valid IP address was found, there is no way to tell
        # which of them is the user's IP address - failure.
        elif [ "$ipAddressValidCounter" -gt "1" ]; then
            # If in test url mode then echo all the valid IP addresses that were found so that
            # the test url mode code section can echo them to aid debugging.
            if [ "$operationMode" = "TESTURL" ]; then echo "$ipAddressList"; fi
            return "$GetIpMultipleValidIP"
        fi
    fi

    # If the url download process timed out (which it must have done or this section of the
    # function would not have been reached) then kill the process (and make doubly sure).

    # Since the process being killed has been disowned (removed from the shell's active jobs
    # table) the redirect of stdout and stderr to /dev/null may be unnecessary to hide the kill
    # messages, it is not necessary on the 3 Linux systems used to test the script, other OSes?

    if [ "$isUrlDownloadTimedOut" = "TRUE" ]; then

        kill -INT "$urlDownloadProcessId" > /dev/null 2>&1
        local killRetVal=$?

        if [ "$killRetVal" -ne "0" ]; then
            kill -KILL "$urlDownloadProcessId" > /dev/null 2>&1
        fi
    fi

    # The download process timed out, return the appropriate constant.
    return "$GetIpTimedOut"
}


# Function that checks that all the IP addresses passed to it are exactly the same.
# It is used to check that all the IP addresses retrieved in multi mode are identical.
Multi_Ip_Check()
{
    # Assign all the IP addresses passed to this function to the array $ipList.
    local ipList=("$@")

    # Iterate through the array checking that all the IP addresses are the same.
    for ipToCheck in "${ipList[@]}"; do

        # If $ipToCheck is not the same as the first IP address in the array, return 1.
        if [ "$ipToCheck" != "${ipList[0]}" ]; then
            return "1"
        fi

    done

    # All the IP addresses in the array must be the same, return 0.
    return "0"
}


# Initiate the various variables used for stats in the check operation mode.
statsValidIpAddressList=""
statsTimesList=""
statsTotalValidIp="0"
statsTotalInValidIp="0"


# Add IP's address, validity, and retrieval time to the statistics variables (used in check mode).
Add_To_Stats()
{
    # Assign the IP address, its validity, and retrieval time to local variables.
    local ipAddressForStats="$1"
    local ipStatusForStats="$2"
    local timeTakenForStats="$3"

    # If the IP address is valid.
    if [ "$ipStatusForStats" = "VALID_IP" ]; then

        # Add the IP address to the list of valid IP addresses. [The trailing space is essential.]
        statsValidIpAddressList+="$ipAddressForStats "

        # Add the time taken to the list of times taken. [The trailing space is essential.]
        statsTimesList+="$timeTakenForStats "

        # Add one to the valid IP address counter.
        let "statsTotalValidIp = statsTotalValidIp + 1"

    # If the IP address is not valid add one to the invalid IP address counter.
    else
        let "statsTotalInValidIp = statsTotalInValidIp + 1"
    fi
}


# Function to find the fastest time from the times in the $statsTimesList list.
Find_Fastest_Time()
{
    # Awk expression to find the fastest time.
    local awkFastest='{ if (NR == 1) fastest = $1; if ($1 < fastest) fastest = $1; } \
                      END { printf("%.3f", fastest) }'

    # Pipe the $statsTimesList to awk to get the fastest time.
    local fastest=$(echo "$statsTimesList" | tr " " "\n" | awk "$awkFastest" )

    # Echo $fastest for capture at point of function invocation.
    echo "$fastest"
}


# Function to find the slowest time from the times in the $statsTimesList list.
Find_Slowest_Time()
{
    # Awk expression to find the slowest time.
    local awkSlowest='{ if (NR == 1) slowest = $1; if ($1 > slowest) slowest = $1; } \
                      END { printf("%.3f", slowest) }'

    # Pipe the $statsTimesList to awk to get the slowest time.
    local slowest=$(echo "$statsTimesList" | tr " " "\n" | awk "$awkSlowest" )

    # Echo $slowest for capture at point of function invocation.
    echo "$slowest"
}


# Function to calculate the mean average of the times in the $statsTimesList list.
Calculate_Mean_Average_Time()
{
    # Awk expression to calculate the mean average.
    local awkMean='{ total = total + $1; } \
                   END { mean = total / numItems; printf("%.3f", mean) }'

    # Pipe the $statsTimesList to awk to get the mean.
    local mean=$(echo "$statsTimesList" | tr " " "\n" |
                 awk "$awkMean" numItems="$statsTotalValidIp")

    # Echo $mean for capture at point of function invocation.
    echo "$mean"
}


# Function to calculate the median average of the times in the $statsTimesList list.
Calculate_Median_Average_Time()
{
    # Establish if there are an even or odd number of times stored in $statsTimesList.
    local medianItemsEvenOrOdd=""
    let 'modTwoOfTotalValidIp = statsTotalValidIp % 2'

    if [ "$modTwoOfTotalValidIp" = "0" ]; then medianItemsEvenOrOdd="EVEN"
    else                                       medianItemsEvenOrOdd="ODD"
    fi

    # If an odd number of items, the median is the middle item in the ordered list.
    if [ "$medianItemsEvenOrOdd" = "ODD" ]; then

        # Work out which is the middle item (integer arithmetic so division will be rounded down).
        local middleItem=""
        let "middleItem = (statsTotalValidIp / 2) + 1"

        # Awk expression to print the middle row which will be the median value.
        local awkMedianOdd='{ if (NR == midRow) printf("%.3f", $1) }'

        # Pipe the $statsTimesList to awk as a sorted list to get the median.
        local median=$(echo "$statsTimesList" | tr " " "\n" | sort -n |
                       awk "$awkMedianOdd" midRow="$middleItem")
    fi

    # If an even number of items, the median is the mean average of the 2 middle items in the
    # ordered list.
    if [ "$medianItemsEvenOrOdd" = "EVEN" ]; then

        # Work out which are the 2 middle items.
        local middleItem1=""
        local middleItem2=""
        let "middleItem1 = statsTotalValidIp / 2"
        let "middleItem2 = middleItem1 + 1"

        # Awk expression to get the values of the 2 middle rows and then to work out and print
        # the median by calculating the mean average of the 2 middle rows.
        local awkMedianEven='{ if (NR == midRow1) med1 = $1; if (NR == midRow2) med2 = $1; } \
                             END { median = (med1 + med2) / 2; printf("%.3f", median) }'

        # Pipe the $statsTimesList to awk as a sorted list to get the median.
        local median=$(echo "$statsTimesList" | tr " " "\n" | sort -n |
                       awk "$awkMedianEven" midRow1="$middleItem1" midRow2="$middleItem2")
    fi

    # Echo $median for capture at point of function invocation.
    echo "$median"
}


# Display the statistics variables (used in check mode).
Display_Stats()
{
    # Trim whitespace from $statsTimesList and $statsValidIpAddressList.
    local sedExpTrim='s/^[ \t]*//g;s/[ \t]*$//g'
    statsTimesList=$(echo "$statsTimesList" | sed "$sedExpTrim")
    statsValidIpAddressList=$(echo "$statsValidIpAddressList" | sed "$sedExpTrim")

    # Find the fastest time of the successful retrieval times (3 decimal places).
    local timeFastest=$(Find_Fastest_Time)

    # Find the slowest time of the successful retrieval times (3 decimal places).
    local timeSlowest=$(Find_Slowest_Time)

    # Calculate the mean average of the successful retrieval times (3 decimal places).
    local timeMean=$(Calculate_Mean_Average_Time)

    # Calculate the median average of the successful retrieval times (3 decimal places).
    local timeMedian=$(Calculate_Median_Average_Time)

    # Calculate the percentages of successful and failed retrieval (2 decimal places).
    local bcExpPercentSuccess="($statsTotalValidIp / $urlArrayLength) * 100"
    local percentSuccess=$(printf "%.2f" $(echo "$bcExpPercentSuccess" | bc -l))
    local bcExpPercentFailed="100 - $percentSuccess"
    local percentFailed=$(printf "%.2f" $(echo "$bcExpPercentFailed" | bc -l))

    # Calculate the number of unique IP addresses held in $statsValidIpAddressList.
    local numUniqueIp=$(echo "$statsValidIpAddressList" | tr " " "\n" | sort -n | uniq | wc -l)

    # Output the statistics.

    echo "-----------------------------------------------------------------------------"

    printf "%-62s %s\n" "Total Number Sites Checked" "$urlArrayLength"

    printf "%-62s %-3s (%s%%)\n" "IP Addresses - Successfully Retrieved" \
                                 "$statsTotalValidIp" "$percentSuccess"

    printf "%-62s %-3s (%s%%)\n" "IP Addresses - Failed (Timed Out / Invalid IP)" \
                                 "$statsTotalInValidIp" "$percentFailed"

    printf "%-62s %s\n" "Timeout For Each Url (sec)" "$timeout"

    printf "%-62s %s\n" "Fastest IP Successful Retrieval (sec)" "$timeFastest"

    printf "%-62s %s\n" "Slowest IP Successful Retrieval (sec)" "$timeSlowest"

    printf "%-62s %s\n" "Mean Average IP Successful Retrieval (sec)" "$timeMean"

    printf "%-62s %s\n" "Median Average IP Successful Retrieval (sec)" "$timeMedian"

    # Issue a warning if not exactly 1 unique IP.
    if [ "$numUniqueIp" = "1" ]; then
        printf "%-62s %s\n" "Unique IP Addresses Retrieved (Should Be 1)" "$numUniqueIp"
    else
        printf "%-62s %s *WARNING*\n" "Unique IP Addresses Retrieved (Should Be 1)" "$numUniqueIp"
    fi

    # Echo a warning if the number of unique IP addresses is > 1, and list them.
    if [ "$numUniqueIp" -gt "1" ]; then
        echo ""
        echo "WARNING: The number of unique IP addresses retrieved exceeds one. It should be"
        echo "exactly one - your IP address - returned by all the sources used for IP address"
        echo "retrieval. One or more of the sources is no longer returning IP addresses"
        echo "correctly. You should download the most recent version of the getip script."
        echo "Advanced users can edit the urls in the script's sourceUrls array to remove"
        echo "urls which are no longer functioning. If the latest version of the script has"
        echo "a non-functioning source url in it, please contact the developer."
        echo ""

        # List each unique IP address in a table along with its number of occurrences.

        # This awk code uses a useful aspect of awk where any number or string in awk may be used
        # as an array index. In this case the IP addresses piped to awk will serve as the array
        # indexes for the countIP[] array. Also in awk if you perform an arithmetic operation to
        # a variable which has not yet been assigned a value then the variable is automatically
        # assigned a value of 0 before the arithmetic operation takes place. So in the code below
        # all the members of the countIP[] array are effectively initialized to 0.
        local awkExpIpCount='{ countIP[$1]++ } END { for (ip in countIP) \
                               printf("%-15d  -  %s\n", countIP[ip], ip); }'

        printf "Unique IP Addresses List:\n\n"
        printf "Num Occurrences  -  IP Address\n"
        echo "$statsValidIpAddressList" | tr " " "\n" | awk "$awkExpIpCount" | sort -n
    fi

    echo "-----------------------------------------------------------------------------"
}


# Flag variable to hold whether in multi or fast mode, some things are only done in these modes.
if [ "$operationMode" = "MULTI" -o "$operationMode" = "FAST" ]; then
    operationModeIsMultiOrFast="TRUE"
else
    operationModeIsMultiOrFast="FALSE"
fi

# Flag variable to hold whether to calculate the time taken to get the IP address,
# this will only be done in either check mode or if verbose is set.
if [ "$operationMode" = "CHECK" -o "$verbose" = "TRUE" ]; then
    timeIpRetrieval="TRUE"
else
    timeIpRetrieval="FALSE"
fi

# If verbose is set, echo various diagnostic information.
if [ "$verbose" = "TRUE" ]; then
    echo "Script Version:      $version"
    echo "Total Source Urls:   $urlArrayLength"
    echo "Operation Mode:      $operationMode"
    if [ "$operationMode" = "MULTI" ]; then
        echo "Num Sources to Use:  $numIpToUseForMulti"
    fi
    if [ "$operationMode" = "TESTURL" ]; then
        echo "Url to Test:         $testUrlAddress"
    fi
    echo "Timeout (Seconds):   $timeout"
    echo "Web Utility:         $urlDownloadProgram"
    echo ""
fi

# Call the function which randomizes the $urlArray array, multi or fast mode only.
if [ "$operationModeIsMultiOrFast" = "TRUE" ]; then

    if [ "$verbose" = "TRUE" ]; then
        echo "Randomizing the list of urls (the sources list)"
    fi

    Randomize_Url_List
fi

# If in test url mode test the url, providing helpful output, and then exit.
if [ "$operationMode" = "TESTURL" ]; then

    # 'Pretty print' the test results.
    printf "%-21s%s\n" "Testing Url:" "$testUrlAddress"

    # Create a temp file for Get_Ip_From_Url() to use. The options used are:
    # -q to fail silently on error and -t to use the system's temp directory.
    tempFileNameForGetIp=$(mktemp -q -t "getip.tmp.XXXXXX")
    mktempFileCreationRetVal=$?

    if [ "$mktempFileCreationRetVal" -ne "0" ]; then
        Output_Error_Message "TempFileCreationFailed"
        exit "$ExitStatusErrorTempFileCreationFailed"
    fi

    # Use the function Get_Ip_From_Url() to retrieve the source $url, store its contents in the
    # $tempFileNameForGetIp temp file, and extract IP addresses from it. If one or more properly
    # formed IP addresses are retrieved then they will be placed in $ipAddress.

    # Time the IP address retrieval.
    timeStart=$(date +%s.%N)

    ipAddress=$(Get_Ip_From_Url "$testUrlAddress" "$tempFileNameForGetIp")
    getIpFromUrlRetVal=$?

    timeStop=$(date +%s.%N)
    timeTaken=$(printf "%.3F" $(echo "$timeStop - $timeStart" | bc -l))

    # Delete the temp file.
    if [ -f "$tempFileNameForGetIp" ]; then rm "$tempFileNameForGetIp"; fi

    # Handle the various return possibilities.

    if [ "$getIpFromUrlRetVal" -eq "$GetIpSingleValidIP" ]; then
        printf "%-21s%s\n" "Status:" "Success"
        printf "%-21s%s\n" "Outcome:" "Url returned a single valid IP address"
        printf "%-21s%s\n" "IP Address:" "$ipAddress"

    elif [ "$getIpFromUrlRetVal" -eq "$GetIpMultipleValidIP" ]; then
        printf "%-21s%s\n" "Status:" "Failure"
        printf "%-21s%s\n" "Outcome:" "Url returned more than one valid IP address"
        ipAddressCSV=$(echo "$ipAddress" | tr '\n' ' ')
        printf "%-21s%s\n" "IP Addresses:" "$ipAddressCSV"

    elif [ "$getIpFromUrlRetVal" -eq "$GetIpNoValidIP" ]; then
        printf "%-21s%s\n" "Status:" "Failure"
        printf "%-21s%s\n" "Outcome:" "Url did not return a valid IP address"

    elif [ "$getIpFromUrlRetVal" -eq "$GetIpTimedOut" ]; then
        printf "%-21s%s\n" "Status:" "Failure"
        printf "%-21s%s\n" "Outcome:" "Server timed out"
    fi

    # Output the time taken and the current timeout value.
    printf "%-21s%s\n" "Duration (Seconds):" "$timeTaken"
    printf "%-21s%s\n" "Timeout  (Seconds):" "$timeout"

    # The exit point of the script in test url mode. Failure codes are not returned if a source
    # did not provide a single valid IP address. This is because test url mode is designed to see
    # if a web url is suitable for adding to the sources list. If the url provides more than a
    # single valid IP address, or none at all, then test url mode still succeded in doing its job.
    exit "$ExitStatusSuccess"
fi

# Array to hold the IP addresses retrieved in multi mode.
multiIpList=""

# Counter to hold how many IP addresses have so far been retrieved in multi mode.
multiIpCounter="0"

# For testing.
#multiIpList[0]="192.111.111.111"
#let "multiIpCounter = multiIpCounter + 1"

# For testing.
#urlArray[0]="http://www.gencon.crius.feralhosting.com/iptest1.html"
#urlArray[0]="http://ipinfo.info/html/my_ip_address.php"
#urlArray[1]="http://torvpn.com/myip.html"

# For testing.
#numIpToUseForMulti=10

# The script's main loop iterates through the urls in the $urlArray array. If in multi or fast mode
# the script will exit from within this loop if the IP address is successfully retrieved (and, if
# in multi mode, then verified). If in check mode the loop will iterate through to completion.

for url in "${urlArray[@]}"; do

    # If in check mode or verbose is set then time the IP address retrieval.
    if [ "$timeIpRetrieval" = "TRUE" ]; then timeStart=$(date +%s.%N); fi

    # If verbose is set and in either multi or fast mode.
    if [ "$verbose" = "TRUE" -a "$operationModeIsMultiOrFast" = "TRUE" ]; then
        echo ""
        echo "Trying: $url"
    fi

    # Create a temp file for Get_Ip_From_Url() to use. The options used are:
    # -q to fail silently on error and -t to use the system's temp directory.
    tempFileNameForGetIp=$(mktemp -q -t "getip.tmp.XXXXXX")
    mktempFileCreationRetVal=$?

    if [ "$mktempFileCreationRetVal" -ne "0" ]; then
        Output_Error_Message "TempFileCreationFailed"
        exit "$ExitStatusErrorTempFileCreationFailed"
    fi

    # Use the function Get_Ip_From_Url() to retrieve the source $url, store its contents in the
    # $tempFileNameForGetIp temp file, and extract IP addresses from it. If a single properly
    # formed IP address gets retrieved then it will be placed in $ipAddress.

    ipAddress=$(Get_Ip_From_Url "$url" "$tempFileNameForGetIp")
    getIpFromUrlRetVal=$?

    # Delete the temp file.
    if [ -f "$tempFileNameForGetIp" ]; then rm "$tempFileNameForGetIp"; fi

    # Set $ipStatus and $ipStatusVerbose on the basis of the Get_Ip_From_Url() function's
    # return value. The possible return values are as follows:

    # $GetIpSingleValidIP      - success, a single valid IP address was retrieved.
    # $GetIpNoValidIP          - failure, no valid IP address at all.
    # $GetIpMultipleValidIP    - failure, more than one valid IP address.
    # $GetIpTimedOut           - failure, the timeout was exceeded.

    if [ "$getIpFromUrlRetVal" -eq "$GetIpSingleValidIP" ]; then
        ipStatus="VALID_IP"
        ipStatusVerbose="Source returned a valid IP address: $ipAddress"

    elif [ "$getIpFromUrlRetVal" -eq "$GetIpNoValidIP" ]; then
        ipStatus="NO_IP_ADDRESS"
        ipStatusVerbose="Source failed: server did not return a valid IP address"

    elif [ "$getIpFromUrlRetVal" -eq "$GetIpMultipleValidIP" ]; then
        ipStatus="IP_NOT_UNIQUE"
        ipStatusVerbose="Source failed: server returned more than one valid IP address"

    elif [ "$getIpFromUrlRetVal" -eq "$GetIpTimedOut" ]; then
        ipStatus="URL_TIMED_OUT"
        ipStatusVerbose="Source failed: server timed out"
    fi

    # If in check mode or verbose is set then time the url download.
    if [ "$timeIpRetrieval" = "TRUE" ]; then timeStop=$(date +%s.%N); fi

    # If in check mode or verbose is set, calculate the time taken (reduce to 3 decimal places).
    if [ "$timeIpRetrieval" = "TRUE" ]; then
        timeTaken=$(printf "%.3F" $(echo "$timeStop - $timeStart" | bc -l))
    fi

    # If verbose is set and in either multi or fast mode.
    if [ "$verbose" = "TRUE" -a "$operationModeIsMultiOrFast" = "TRUE" ]; then
        echo "$ipStatusVerbose"
        echo "Duration (seconds): $timeTaken"
    fi

    # Code to handle the operation mode: FAST

    # If operating in fast mode and $ipAddress contains a properly formed IP address, then echo
    # the IP address and exit the script.

    if [ "$operationMode" = "FAST" -a "$ipStatus" = "VALID_IP" ]; then

        if [ "$verbose" = "TRUE" ]; then
            echo ""
            echo "Using fast mode is not guaranteed to be totally reliable, from time to time"
            echo "a web source will stop supplying IP addresses, in such cases an example IP"
            echo "address on the site, or a software version number, could be given as your IP"
            echo "address. The default multi mode verifies your IP address on 2 or more sites"
            echo "and is very reliable. Fast mode should only be used to confirm a known IP"
            echo "address, for instance when connecting or disconnecting a VPN. See -h."
            echo ""
            echo "IPv4 address: $ipAddress"
        else
            if [ "$bareOutput" = "TRUE" ]; then
                echo "$ipAddress"
            else
                echo "IPv4 address: $ipAddress"
            fi
        fi

        exit "$ExitStatusSuccess"
    fi

    # Code to handle the operation mode: MULTI

    # If operating in multi mode store valid IP addresses in an array and use Multi_Ip_Check() to
    # check that all the IPs in the array are the same. If they are all the same and the required
    # number of IP addresses to use for verification have been retrieved, then the IP address can
    # be echoed and the script can exit. If the IP addresses in the array are not all the same
    # then reset the variables and keep going so that different sources are then used.

    if [ "$operationMode" = "MULTI" -a "$ipStatus" = "VALID_IP" ]; then

        # Add the IP address to the verify array, and add 1 to the counter.
        multiIpList[$multiIpCounter]="$ipAddress"
        let "multiIpCounter = multiIpCounter + 1"

        # If verbose is set...
        if [ "$verbose" = "TRUE" ]; then
            echo "Adding IP address to multi list: $multiIpCounter of $numIpToUseForMulti"
        fi

        # Check if all the IP addresses in the array are the same.
        Multi_Ip_Check "${multiIpList[@]}"
        multiIpCheckRetVal=$?

        # If the IP addresses in the array are not all the same then reset the variables.
        if [ "$multiIpCheckRetVal" -ne "0" ]; then

            if [ "$verbose" = "TRUE" ]; then
                echo ""
                echo "The multi mode verification process failed, the $multiIpCounter IP addresses"
                echo "already retrieved are not identical. The script will discard"
                echo "these IP addresses and start again with different sources."
            fi

            # Reset the array and counter variables.
            unset multiIpList
            multiIpCounter="0"
        fi

        # The array contains the required number of IP addresses to use for verification.
        # Note: The if statement below will only evaluate to true if the IP addresses in the array
        # are all the same, if they weren't then $multiIpCounter would have been set to 0 above.
        if [ "$multiIpCounter" -eq "$numIpToUseForMulti" ]; then

            # If verbose is set...
            if [ "$verbose" = "TRUE" ]; then
                echo ""
                echo "The multi mode verification process has succeeded, the $multiIpCounter IP"
                echo "addresses retrieved from different web sources are identical."
                echo ""
                echo "IPv4 address: $ipAddress"
            else
                if [ "$bareOutput" = "TRUE" ]; then
                    echo "$ipAddress"
                else
                    echo "IPv4 address: $ipAddress"
                fi
            fi

            exit "$ExitStatusSuccess"
        fi
    fi

    # Code to handle the operation mode: CHECK

    # If operating in check mode neatly display the source url, the IP address or an error
    # message if retrieving it failed, and the time taken to retrieve the IP address, for
    # each of the source urls and format the data as a table.

    if [ "$operationMode" = "CHECK" ]; then

        # awk expression for 'pretty printing' the test results.
        awkExprPrettyPrint='{ printf "%-8s %-53s %s\n", $1, $2, $3 }'

        # If the length of $url will muck up 'pretty printing', truncate it.
        urlLength=${#url}
        if [ "$urlLength" -gt "52" ]; then
            truncateUrl=${url:0:48}
            url="$truncateUrl..."
        fi

        # Pretty print the information in neat columns: time, url, IP Address / Error.
        if [ "$ipStatus" = "VALID_IP" ]; then
            echo "$timeTaken" "$url" "$ipAddress" | awk "$awkExprPrettyPrint"
        else
            echo "$timeTaken" "$url" "$ipStatus" | awk "$awkExprPrettyPrint"
        fi

        # Add info. to the stored statistics for displaying at the end.
        Add_To_Stats "$ipAddress" "$ipStatus" "$timeTaken"
    fi

done  # End of loop through $urlArray loop.


# If operating in multi or fast mode, then if this section of the script is reached then the
# script failed to supply a valid IP address. This would typically indicate that web access is
# currently unavailable.
if [ "$operationModeIsMultiOrFast" = "TRUE" ]; then

    echo "The script failed to get the IP address. The most likely reasons for this"
    echo "failure are that there is currently no web access available to the computer,"
    echo "some part of the security system is denying getip a web connection, or"
    echo "possibly the timeout value has been set very low. If you have web access and"
    echo "this script is very old, you could download the latest version of the script."

    exit "$ExitStatusErrorMultiOrFastModeGettingIpFailed"
fi

# If operating in check mode, then display the check mode statistics.

if [ "$operationMode" = "CHECK" ]; then

    # Write an error message if all the urls failed.
    if [ "$statsTotalInValidIp" -eq "$urlArrayLength" ]; then
        Output_Error_Message "CheckModeAllUrlsFailed"
        exit "$ExitStatusErrorCheckModeAllUrlsFailed"
    fi

    # Display the stats info.
    Display_Stats
fi

# The exit point of the script in check mode.
exit "$ExitStatusSuccess"

##
## END OF SCRIPT.
##

